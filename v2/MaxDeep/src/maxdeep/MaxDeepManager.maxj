package maxdeep;

// import com.maxeler.maxcompiler.v2.build.EngineParameters;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;
// import com.maxeler.maxcompiler.v2.managers.custom.CustomManager.LMemFrequency;
import com.maxeler.maxcompiler.v2.managers.custom.ManagerClock;
// import com.maxeler.maxcompiler.v2.managers.custom.DFELink;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelConfiguration;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.*;
import com.maxeler.maxcompiler.v2.managers.custom.stdlib.*;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceMath;
// import com.maxeler.maxcompiler.v2.managers.custom.stdlib.MemoryControllerConfig;
import com.maxeler.maxcompiler.v2.managers.BuildConfig;

import com.custom_computing_ic.dfe_snippets.manager.ManagerUtils;
import com.custom_computing_ic.dfe_snippets.kernels.PaddingKernel;
import com.custom_computing_ic.dfe_snippets.kernels.UnpaddingKernel;

import maxdeep.designs.*;

public class MaxDeepManager extends CustomManager {

  /**
   * LMem related members
   */
  protected LMemInterface iface;
  protected LMemCommandGroup group;
  protected LMemCommandGroup groupWgt;
  protected LMemCommandGroup groupOut;
  public static final String LMEM_INP_NAME = "LMEM_INP";
  public static final String LMEM_WGT_NAME = "LMEM_WGT";
  public static final String LMEM_OUT_NAME = "LMEM_OUT";

  /**
   * Manager clocks
   */
  public static final String DEFAULT_CLK_NAME = "DEFAULT_STREAM_CLOCK";
  public ManagerClock clk;

  /**
   * Kernel instance names
   */
  public static final String LOOPBACK_KERNEL_NAME       = "LOOPBACK_KERNEL";
  public static final String MULT_ARRAY_KERNEL_NAME     = "MULT_ARRAY_KERNEL";
  public static final String ONE_DIM_CONV_KERNEL_NAME   = "ONE_DIM_CONV_KERNEL";
  public static final String CONV2D_COMPUTE_KERNEL_NAME = "CONV2D_COMPUTE_KERNEL";
  public static final String PADDING_KERNEL_NAME        = "PADDING_KERNEL";
  public static final String UNPADDING_INP_KERNEL_NAME  = "UNPADDING_INP_KERNEL";
  public static final String UNPADDING_WGT_KERNEL_NAME  = "UNPADDING_WGT_KERNEL";

  /**
   * Shared kernel blocks
   */
  public KernelBlock padding;
  public KernelBlock unpadding_inp;
  public KernelBlock unpadding_wgt;

  public MaxDeepManager(MaxDeepEngineParameters params) {
    super(params);

    config.setAllowNonMultipleTransitions(true);

    initializeMaxFileConstants(params);
    initializeManagerClocks(params);
    initializeLMemInterface(params);

    if (params.getDesignName().equals("LOOPBACK")) {
      initializeLoopbackKernel(params, false);
    } else if (params.getDesignName().equals("LOOPBACK_PADDED")) {
      initializeLoopbackKernel(params, true);
    } else if (params.getDesignName().equals("MULT_ARRAY")) {
      initializeMultArrayKernel(params);
    } else if (params.getDesignName().equals("ONE_DIM_CONV")) {
      initializeOneDimConvKernel(params); 
    } else if (params.getDesignName().equals(Conv2DDesign.NAME)) {
      Conv2DDesign.initializeKernel(this, params);
    } else {
      throw new IllegalArgumentException(
          String.format("Design name \"%s\" cannot be recognized",
            params.getDesignName()));
    }
  }

  public EngineInterface interfaceDefault(MaxDeepEngineParameters params) {
    EngineInterface ei = new EngineInterface();

    if (params.getDesignName().equals("LOOPBACK"))
      initializeEngineInterfaceForLoopback(ei);
    else if (params.getDesignName().equals("LOOPBACK_PADDED"))
      initializeEngineInterfaceForLoopbackPadded(ei);
    else if (params.getDesignName().equals("MULT_ARRAY"))
      initializeEngineInterfaceForMultArray(ei, params);
    else if (params.getDesignName().equals("ONE_DIM_CONV"))
      initializeEngineInterfaceForOneDimConv(ei, params);
    else if (params.getDesignName().equals(Conv2DDesign.NAME))
      Conv2DDesign.initializeEngineInterface(ei, this, params);
    else
      throw new IllegalArgumentException(
          String.format("Design name \"%s\" cannot be recognized",
            params.getDesignName()));

    ManagerUtils.ignoreLMemStreams(ei);
    return ei;
  }

  /**
   * Initialize the LMemInterface within this manager.
   *
   * @author Ruizhe Zhao
   * @since 16/05/2017
   */
  private void initializeLMemInterface(MaxDeepEngineParameters params) {
    iface = addLMemInterface();
    group = iface.addCommandGroup(
        "GROUP", LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
    groupWgt = iface.addCommandGroup(
        "GROUP_WGT", LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
    groupOut = iface.addCommandGroup(
        "GROUP_OUT", LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
  }

  private void initializeMaxFileConstants(MaxDeepEngineParameters params) {
    addMaxFileConstant("NUM_PIPES", params.getNumPipes());
    addMaxFileConstant("KERNEL_SIZE", params.getKernelSize());
    addMaxFileConstant("ONE_DIM_CONV_WINDOW_WIDTH", params.getOneDimConvWindowWidth());
  }

  /**
   * Initialize manager clock for kernels within this manager.
   *
   * Currently only the clk is initialized, other clocks that has different
   * clock frequencies will be added later.
   *
   * Also, the default stream clock will be altered.
   * 
   * @author Ruizhe Zhao
   * @since 16/05/2017
   */
  private void initializeManagerClocks(MaxDeepEngineParameters params) {
    clk = generateStreamClock(DEFAULT_CLK_NAME, params.getFreq());

    config.setDefaultStreamClockFrequency(params.getFreq());
  }

  /**
   * Create a LoopbackKernel instance, and connects it
   * to the LMem interface.
   * @author Ruizhe Zhao
   * @since 16/05/2017
   *
   * @param params engine parameters
   * @param is_padded whether to connect the loopback kernel block to padding kernels
   */
  private void initializeLoopbackKernel(MaxDeepEngineParameters params, boolean is_padded) {
    KernelBlock loopback = addKernel(
        new LoopbackKernel(
          makeKernelParameters(MaxDeepManager.LOOPBACK_KERNEL_NAME)));
     
    if (!is_padded) {
      ManagerUtils.addLinearStreamFromLMemToKernel(
          group, loopback, LMEM_INP_NAME, LoopbackKernel.INP_NAME);
      ManagerUtils.addLinearStreamFromLMemToKernel(
          groupWgt, loopback, LMEM_WGT_NAME, LoopbackKernel.WGT_NAME);
      ManagerUtils.addLinearStreamFromKernelToLMem(
          groupOut, loopback, LoopbackKernel.OUT_NAME, LMEM_OUT_NAME);
    } else {
      initializePaddingKernels(params);
      loopback.getInput(LoopbackKernel.INP_NAME) <==
        unpadding_inp.getOutput(UnpaddingKernel.OUT_NAME);
      loopback.getInput(LoopbackKernel.WGT_NAME) <==
        unpadding_wgt.getOutput(UnpaddingKernel.OUT_NAME);
      padding.getInput(PaddingKernel.INP_NAME) <==
        loopback.getOutput(LoopbackKernel.OUT_NAME);
    }

    loopback.setClock(clk);
  }

  /**
   * Initialilze a kernel block for MultArrayKernel.
   * @author Ruizhe Zhao
   * @since 19/05/2017
   */
  private void initializeMultArrayKernel(MaxDeepEngineParameters params) {
    logMsg("Initializing MULT_ARRAY kernel ...");
    logMsg("FREQ:      %d", params.getFreq());
    logMsg("NUM_PIPES: %d", params.getNumPipes());

    KernelBlock multArray = addKernel(
        new MultArrayKernel(
          makeKernelParameters(MaxDeepManager.MULT_ARRAY_KERNEL_NAME),
          params.getNumPipes(),
          params.getDbg()));

    initializePaddingKernels(params);
    // By defaut, multArray will be connected directly to padding
    // and unpadding kernels
    multArray.getInput(MultArrayKernel.INP_NAME) <==
      unpadding_inp.getOutput(UnpaddingKernel.OUT_NAME);
    multArray.getInput(MultArrayKernel.WGT_NAME) <==
      unpadding_wgt.getOutput(UnpaddingKernel.OUT_NAME);
    padding.getInput(PaddingKernel.INP_NAME) <==
      multArray.getOutput(MultArrayKernel.OUT_NAME);

    multArray.setClock(clk);
  }

  /**
   * Create an one dimensional convolution kernel.
   *
   * @author Ruizhe Zhao
   * @since 20/05/2017
   */
  private void initializeOneDimConvKernel(MaxDeepEngineParameters params) {
    // Get specific parameters from params
    int windowWidth = params.getOneDimConvWindowWidth();
    int numPipes = params.getNumPipes();

    logMsg("Initializing ONE_DIM_CONV kernel ...");
    logMsg("FREQ:                 %d", params.getFreq());
    logMsg("WINDOW_WIDTH:         %d", windowWidth);
    logMsg("MULTI_PUMPING_FACTOR: %d", params.getMultiPumpingFactor());
    logMsg("NUM_PIPES:            %d", numPipes);

    initializePaddingKernels(params, 32 * numPipes, 32 * numPipes, 32 * numPipes);

    // Add the kernel block to the manager
    KernelBlock oneDimConv = addKernel(
        new OneDimConvKernel(
          makeKernelParameters(ONE_DIM_CONV_KERNEL_NAME),
          windowWidth,
          numPipes,
          params.getMultiPumpingFactor(),
          params.getDbg()));

    // Connect the kernel block to padding kernels
    oneDimConv.getInput(OneDimConvKernel.INP_NAME) <==
      unpadding_inp.getOutput(UnpaddingKernel.OUT_NAME);
    oneDimConv.getInput(OneDimConvKernel.WGT_NAME) <==
      unpadding_wgt.getOutput(UnpaddingKernel.OUT_NAME);
    padding.getInput(PaddingKernel.INP_NAME) <==
      oneDimConv.getOutput(OneDimConvKernel.OUT_NAME);

    // Set the clock for this kernel block
    oneDimConv.setClock(
        generateStreamClock(
          "MULTI_PUMPED_CLOCK",
          params.getFreq() * params.getMultiPumpingFactor()));
  }

  /**
   * Create padding kernels and connect them to LMem.
   *
   * @author Ruizhe Zhao
   * @since 18/05/2017
   */
  private void initializePaddingKernels(MaxDeepEngineParameters params) {
    initializePaddingKernels(params, 32, 32, 32);
  }

  /**
   * Create padding kernels and connect them to LMem.
   *
   * @author Ruizhe Zhao
   * @since 21/05/2017
   */
  public void initializePaddingKernels(MaxDeepEngineParameters params,
      int inpBitWidth, int wgtBitWidth, int outBitWidth) {
    padding = addKernel(
        new PaddingKernel(
          makeKernelParameters(MaxDeepManager.PADDING_KERNEL_NAME),
          outBitWidth, params.getDbg()));
    unpadding_inp = addKernel(
        new UnpaddingKernel(
          makeKernelParameters(MaxDeepManager.UNPADDING_INP_KERNEL_NAME),
          inpBitWidth, params.getDbg()));
    unpadding_wgt = addKernel(
        new UnpaddingKernel(
          makeKernelParameters(MaxDeepManager.UNPADDING_WGT_KERNEL_NAME),
          wgtBitWidth, params.getDbg()));

    ManagerUtils.addLinearStreamFromLMemToKernel(
        group, unpadding_inp, LMEM_INP_NAME, UnpaddingKernel.INP_NAME);
    ManagerUtils.addLinearStreamFromLMemToKernel(
        groupWgt, unpadding_wgt, LMEM_WGT_NAME, UnpaddingKernel.INP_NAME);
    ManagerUtils.addLinearStreamFromKernelToLMem(
        groupOut, padding, PaddingKernel.OUT_NAME, LMEM_OUT_NAME);

    // Don't need to explicitly set the clock source for padding kernels
    // padding.setClock(clk);
    // unpadding_inp.setClock(clk);
    // unpadding_wgt.setClock(clk);
  }

  /**
   * Create an engine interface for the loopback test.
   *
   * @author Ruizhe Zhao
   * @since 16/05/2017
   * @param ei Engine interface to be updated
   */
  private void initializeEngineInterfaceForLoopback(EngineInterface ei) {
    InterfaceParam N =
      ei.addParam(
          "num_elems",
          CPUTypes.INT32,
          "Number of elements to be transferred");
    InterfaceParam ZERO = ei.addConstant(0);
    InterfaceParam sizeInBytes = N * CPUTypes.UINT32.sizeInBytes();

    ei.setTicks(MaxDeepManager.LOOPBACK_KERNEL_NAME, N);
    ei.setLMemLinear(LMEM_INP_NAME, ZERO, sizeInBytes);
    ei.setLMemLinear(LMEM_WGT_NAME, sizeInBytes, sizeInBytes);
    ei.setLMemLinear(LMEM_OUT_NAME, 2 * sizeInBytes, sizeInBytes);
  }

  /**
   * Create LOOPBACK_PADDED related configuration in the engine interface.
   *
   * @author Ruizhe Zhao
   * @since 18/05/2017
   */
  private void initializeEngineInterfaceForLoopbackPadded(EngineInterface ei) {
    InterfaceParam N =
      ei.addParam(
          "num_elems",
          CPUTypes.INT64,
          "Number of elements to be transferred");
    InterfaceParam ZERO = ei.addConstant(0);
    InterfaceParam sizeInBytes = N * CPUTypes.UINT32.sizeInBytes();
    InterfaceParam burstAlignedNumOfElems =
      getBurstAlignedNumOfElems(N, CPUTypes.UINT32.sizeInBytes(), ei);
    InterfaceParam burstAlignedSizeInBytes = burstAlignedNumOfElems * CPUTypes.UINT32.sizeInBytes();

    ei.setTicks(LOOPBACK_KERNEL_NAME, N);
    ei.setTicks(PADDING_KERNEL_NAME, burstAlignedNumOfElems);
    ei.setTicks(UNPADDING_INP_KERNEL_NAME, burstAlignedNumOfElems);
    ei.setTicks(UNPADDING_WGT_KERNEL_NAME, burstAlignedNumOfElems);

    ei.setScalar(PADDING_KERNEL_NAME,       PaddingKernel.SCALAR_NUM_INP,        N);
    ei.setScalar(PADDING_KERNEL_NAME,       PaddingKernel.SCALAR_TOTAL_CYCLES,   burstAlignedNumOfElems);
    ei.setScalar(UNPADDING_INP_KERNEL_NAME, UnpaddingKernel.SCALAR_NUM_INP,      N);
    ei.setScalar(UNPADDING_INP_KERNEL_NAME, UnpaddingKernel.SCALAR_TOTAL_CYCLES, burstAlignedNumOfElems);
    ei.setScalar(UNPADDING_WGT_KERNEL_NAME, UnpaddingKernel.SCALAR_NUM_INP,      N);
    ei.setScalar(UNPADDING_WGT_KERNEL_NAME, UnpaddingKernel.SCALAR_TOTAL_CYCLES, burstAlignedNumOfElems);

    ei.setLMemLinear(LMEM_INP_NAME, ZERO, burstAlignedSizeInBytes);
    ei.setLMemLinear(LMEM_WGT_NAME, burstAlignedSizeInBytes, burstAlignedSizeInBytes);
    ei.setLMemLinear(LMEM_OUT_NAME, 2 * burstAlignedSizeInBytes, burstAlignedSizeInBytes);
  }

  /**
   * Create MULT_ARRAY related configuration in the engine interface.
   *
   * @author Ruizhe Zhao
   * @since 19/05/2017
   */
  private void initializeEngineInterfaceForMultArray(
      EngineInterface ei, MaxDeepEngineParameters params) {
    InterfaceParam N =
      ei.addParam(
          "num_elems",
          CPUTypes.INT64,
          "Number of elements to be transferred to the INP stream");
    InterfaceParam ZERO = ei.addConstant(0);

    InterfaceParam inpNumElems = N;
    InterfaceParam wgtNumElems = N * params.getNumPipes();

    InterfaceParam burstAlignedInpNumOfElems =
      getBurstAlignedNumOfElems(inpNumElems, CPUTypes.UINT32.sizeInBytes(), ei);
    InterfaceParam burstAlignedInpSizeInBytes = burstAlignedInpNumOfElems * CPUTypes.UINT32.sizeInBytes();
    
    InterfaceParam burstAlignedWgtNumOfElems =
      getBurstAlignedNumOfElems(wgtNumElems, CPUTypes.UINT32.sizeInBytes(), ei);
    InterfaceParam burstAlignedWgtSizeInBytes = burstAlignedWgtNumOfElems * CPUTypes.UINT32.sizeInBytes();

    ei.setTicks(MULT_ARRAY_KERNEL_NAME, N);
    ei.setTicks(PADDING_KERNEL_NAME, burstAlignedInpNumOfElems);
    ei.setTicks(UNPADDING_INP_KERNEL_NAME, burstAlignedInpNumOfElems);
    ei.setTicks(UNPADDING_WGT_KERNEL_NAME, burstAlignedWgtNumOfElems);

    ei.setScalar(PADDING_KERNEL_NAME, PaddingKernel.SCALAR_NUM_INP, inpNumElems);
    ei.setScalar(PADDING_KERNEL_NAME, PaddingKernel.SCALAR_TOTAL_CYCLES, burstAlignedInpNumOfElems);
    ei.setScalar(UNPADDING_INP_KERNEL_NAME, UnpaddingKernel.SCALAR_NUM_INP, inpNumElems);
    ei.setScalar(UNPADDING_INP_KERNEL_NAME, UnpaddingKernel.SCALAR_TOTAL_CYCLES, burstAlignedInpNumOfElems);
    ei.setScalar(UNPADDING_WGT_KERNEL_NAME, UnpaddingKernel.SCALAR_NUM_INP, wgtNumElems);
    ei.setScalar(UNPADDING_WGT_KERNEL_NAME, UnpaddingKernel.SCALAR_TOTAL_CYCLES, burstAlignedWgtNumOfElems);

    ei.setLMemLinear(LMEM_INP_NAME, ZERO, burstAlignedInpSizeInBytes);
    ei.setLMemLinear(LMEM_WGT_NAME, burstAlignedInpSizeInBytes, burstAlignedWgtSizeInBytes);
    ei.setLMemLinear(LMEM_OUT_NAME, burstAlignedInpSizeInBytes + burstAlignedWgtSizeInBytes,
        burstAlignedInpSizeInBytes);
  }


  /**
   * Create an engine interface for the ONE_DIM_CONV design.
   *
   * @author Ruizhe Zhao
   * @since 20/05/2017
   */
  private void initializeEngineInterfaceForOneDimConv(
      EngineInterface ei, MaxDeepEngineParameters params) {

    // Add parameters for the SLiC interface:
    // One parameter for the total number of lines
    InterfaceParam totalNumOfLines = ei.addParam(
        "total_num_of_lines",
        CPUTypes.INT64,
        "Number of lines to be convolved");
    
    // One parameter for the line width
    InterfaceParam lineWidth = ei.addParam(
        "line_width",
        CPUTypes.INT64,
        "Width of each line");

    InterfaceParam ZERO = ei.addConstant(0);
    InterfaceParam windowWidth = ei.addConstant(params.getOneDimConvWindowWidth());
    InterfaceParam numOfPipes = ei.addConstant(params.getNumPipes());

    // Compute the number of input elements required, should equal
    // to lineWidth * totalNumOfLines
    InterfaceParam inpNumOfElems = lineWidth * totalNumOfLines;

    // Compute the number of weight elements required, should equal to
    // totalNumOfLines * windowWidth
    InterfaceParam wgtNumOfElems = windowWidth  * totalNumOfLines;

    // Compute the number of expected number of output: the number of
    // output for each line is (lineWidth - windowWidth + 1)
    InterfaceParam outNumOfElems = (lineWidth - windowWidth + 1) * totalNumOfLines;

    // Compute the burst aligned number of input elements
    InterfaceParam burstAlignedInpNumOfElems =
      getBurstAlignedNumOfElems(inpNumOfElems, CPUTypes.UINT32.sizeInBytes(), ei);
    InterfaceParam burstAlignedInpSizeInBytes =
      burstAlignedInpNumOfElems * CPUTypes.UINT32.sizeInBytes();

    // Compute the burst aligned number of weight elements
    InterfaceParam burstAlignedWgtNumOfElems =
      getBurstAlignedNumOfElems(wgtNumOfElems, CPUTypes.UINT32.sizeInBytes(), ei);
    InterfaceParam burstAlignedWgtSizeInBytes =
      burstAlignedWgtNumOfElems * CPUTypes.UINT32.sizeInBytes();

    // Compute the burst aligned number of output elements
    InterfaceParam burstAlignedOutNumOfElems =
      getBurstAlignedNumOfElems(outNumOfElems, CPUTypes.UINT32.sizeInBytes(), ei);
    InterfaceParam burstAlignedOutSizeInBytes =
      burstAlignedOutNumOfElems * CPUTypes.UINT32.sizeInBytes();

    // Set ticks for ONE_DIM_CONV_KERNEL and padding kernels, the number of ticks
    // for the ONE_DIM_CONV_KERNEL should equal to the total number of input
    // elements, divided by the number of pipes
    ei.setTicks(ONE_DIM_CONV_KERNEL_NAME,
        inpNumOfElems / numOfPipes * params.getMultiPumpingFactor());
    ei.setTicks(PADDING_KERNEL_NAME, burstAlignedOutNumOfElems / numOfPipes);
    ei.setTicks(UNPADDING_INP_KERNEL_NAME, burstAlignedInpNumOfElems / numOfPipes);
    ei.setTicks(UNPADDING_WGT_KERNEL_NAME, burstAlignedWgtNumOfElems / numOfPipes);

    // Set scalar for ONE_DIM_CONV_KERNEL (lineWidth) and for padding kernels
    ei.setScalar(ONE_DIM_CONV_KERNEL_NAME, OneDimConvKernel.SCALAR_LINE_WIDTH_NAME, lineWidth);
    ei.setScalar(PADDING_KERNEL_NAME, PaddingKernel.SCALAR_NUM_INP, outNumOfElems / numOfPipes);
    ei.setScalar(PADDING_KERNEL_NAME, PaddingKernel.SCALAR_TOTAL_CYCLES, burstAlignedOutNumOfElems / numOfPipes);
    ei.setScalar(UNPADDING_INP_KERNEL_NAME, UnpaddingKernel.SCALAR_NUM_INP, inpNumOfElems / numOfPipes);
    ei.setScalar(UNPADDING_INP_KERNEL_NAME, UnpaddingKernel.SCALAR_TOTAL_CYCLES, burstAlignedInpNumOfElems / numOfPipes);
    ei.setScalar(UNPADDING_WGT_KERNEL_NAME, UnpaddingKernel.SCALAR_NUM_INP, wgtNumOfElems / numOfPipes);
    ei.setScalar(UNPADDING_WGT_KERNEL_NAME, UnpaddingKernel.SCALAR_TOTAL_CYCLES, burstAlignedWgtNumOfElems / numOfPipes);

    // Set LMem stream base address and size
    ei.setLMemLinear(LMEM_INP_NAME, ZERO, burstAlignedInpSizeInBytes);
    ei.setLMemLinear(LMEM_WGT_NAME, burstAlignedInpSizeInBytes, burstAlignedWgtSizeInBytes);
    ei.setLMemLinear(LMEM_OUT_NAME, burstAlignedInpSizeInBytes + burstAlignedWgtSizeInBytes,
        burstAlignedOutSizeInBytes);
  }

  /**
   * Get the burst aligned number of elements from the current number of elements and
   * the size of the data type in bytes.
   *
   * @author Ruizhe Zhao
   * @since 19/05/2017
   *
   * @param numOfElems number of elements of the original array
   * @param sizeInBytes size of an array element in bytes
   * @param ei engine interface to be used
   * @return number of elements in the burst aligned array
   */
  public InterfaceParam getBurstAlignedNumOfElems(InterfaceParam numOfElems, int sizeInBytes,
      EngineInterface ei) {
    InterfaceParam burstSize = ei.addConstant(384);
    InterfaceParam totalSizeInBytes = numOfElems * sizeInBytes;
    InterfaceParam burstAlignedTotalSizeInBytes =
      InterfaceMath
      .ceil(
          totalSizeInBytes.cast(CPUTypes.DOUBLE) /
          burstSize.cast(CPUTypes.DOUBLE))
      .cast(CPUTypes.INT64) * burstSize;
    InterfaceParam burstAlignedNumOfElems =
      burstAlignedTotalSizeInBytes / sizeInBytes;
    return burstAlignedNumOfElems.cast(CPUTypes.INT64);
  }

  public static void main(String [] args) {
    MaxDeepEngineParameters params = new MaxDeepEngineParameters(args);
    MaxDeepManager manager = new MaxDeepManager(params);

    manager.createSLiCinterface(ManagerUtils.dramWrite(manager, manager.iface));
    manager.createSLiCinterface(ManagerUtils.dramRead(manager, manager.iface));
    manager.createSLiCinterface(manager.interfaceDefault(params));

    if (params.getDbg())
      ManagerUtils.debug(manager);
    // NOTE: Please don't uncomment this line of code until you know
    // what you are doing!!!
    // NOTE: Maybe it is not due to this line of code, it is due to
    // not-seperated LMemCommandGroups.
    // NOTE: Hmm no, when setting LMem freq to 800 there will always be 
    // a problem
    // ManagerUtils.setDRAMMaxDeviceFrequency(manager, params);

    /**
     * NOTE: Set the DRAM frequency to 400MHz to avoid performance
     * bottleneck at the memory controller.
     */
    ManagerUtils.setDRAMFreq(manager, params, 400);
    if (params.getFreq() > 150 || params.getMultiPumpingFactor() > 1)
      ManagerUtils.setFullBuild(manager, BuildConfig.Effort.HIGH, 6, 6);
    else if (params.getFreq() >= 120)
      ManagerUtils.setFullBuild(manager, BuildConfig.Effort.MEDIUM, 4, 4);
    else
      // to LOW effort, and remain at least two CTs,
      // or it will definitely fail.
      ManagerUtils.setFullBuild(manager, BuildConfig.Effort.MEDIUM, 2, 2);

    manager.build();
  }
}
