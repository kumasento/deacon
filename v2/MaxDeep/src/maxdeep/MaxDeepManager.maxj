package maxdeep;

// import com.maxeler.maxcompiler.v2.build.EngineParameters;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;
// import com.maxeler.maxcompiler.v2.managers.custom.CustomManager.LMemFrequency;
import com.maxeler.maxcompiler.v2.managers.custom.ManagerClock;
// import com.maxeler.maxcompiler.v2.managers.custom.DFELink;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelConfiguration;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.*;
import com.maxeler.maxcompiler.v2.managers.custom.stdlib.*;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceMath;
// import com.maxeler.maxcompiler.v2.managers.custom.stdlib.MemoryControllerConfig;
import com.maxeler.maxcompiler.v2.managers.BuildConfig;

import com.custom_computing_ic.dfe_snippets.manager.ManagerUtils;
import com.custom_computing_ic.dfe_snippets.kernels.PaddingKernel;
import com.custom_computing_ic.dfe_snippets.kernels.UnpaddingKernel;

class MaxDeepManager extends CustomManager {

  /**
   * LMem related members
   */
  protected LMemInterface iface;
  protected LMemCommandGroup group;
  public static final String LMEM_INP_NAME = "LMEM_INP";
  public static final String LMEM_WGT_NAME = "LMEM_WGT";
  public static final String LMEM_OUT_NAME = "LMEM_OUT";

  /**
   * Manager clocks
   */
  public static final String DEFAULT_CLK_NAME = "DEFAULT_STREAM_CLOCK";
  private ManagerClock clk;

  /**
   * Kernel instance names
   */
  public static final String LOOPBACK_KERNEL_NAME = "LOOPBACK_KERNEL";
  public static final String MULT_ARRAY_KERNEL_NAME = "MULT_ARRAY_KERNEL";
  public static final String PADDING_KERNEL_NAME = "PADDING_KERNEL";
  public static final String UNPADDING_INP_KERNEL_NAME = "UNPADDING_INP_KERNEL";
  public static final String UNPADDING_WGT_KERNEL_NAME = "UNPADDING_WGT_KERNEL";

  /**
   * Shared kernel blocks
   */
  private KernelBlock padding;
  private KernelBlock unpadding_inp;
  private KernelBlock unpadding_wgt;

  public MaxDeepManager(MaxDeepEngineParameters params) {
    super(params);

    initializeMaxFileConstants(params);
    initializeManagerClocks(params);
    initializeLMemInterface(params);

    if (params.getDesignName().equals("LOOPBACK")) {
      initializeLoopbackKernel(params, false);
    } else if (params.getDesignName().equals("LOOPBACK_PADDED")) {
      initializePaddingKernels(params);
      initializeLoopbackKernel(params, true);
    } else if (params.getDesignName().equals("MULT_ARRAY")) {
      initializePaddingKernels(params);
      initializeMultArrayKernel(params);
    } else {
      throw new IllegalArgumentException(
          String.format("Design name \"%s\" cannot be recognized",
            params.getDesignName()));
    }
  }

  /**
   * Initialize the LMemInterface within this manager.
   *
   * @author Ruizhe Zhao
   * @since 16/05/2017
   */
  private void initializeLMemInterface(MaxDeepEngineParameters params) {
    iface = addLMemInterface();
    group = iface.addCommandGroup(
        "control", LMemCommandGroup.MemoryAccessPattern.LINEAR_1D);
  }

  private void initializeMaxFileConstants(MaxDeepEngineParameters params) {
    addMaxFileConstant("NUM_PIPES", params.getNumPipes());
  }

  /**
   * Initialize manager clock for kernels within this manager.
   *
   * Currently only the clk is initialized, other clocks that has different
   * clock frequencies will be added later.
   *
   * Also, the default stream clock will be altered.
   * 
   * @author Ruizhe Zhao
   * @since 16/05/2017
   */
  private void initializeManagerClocks(MaxDeepEngineParameters params) {
    clk = generateStreamClock(DEFAULT_CLK_NAME, params.getFreq());

    config.setDefaultStreamClockFrequency(params.getFreq());
  }

  /**
   * Create a LoopbackKernel instance, and connects it
   * to the LMem interface.
   * @author Ruizhe Zhao
   * @since 16/05/2017
   *
   * @param params engine parameters
   * @param is_padded whether to connect the loopback kernel block to padding kernels
   */
  private void initializeLoopbackKernel(MaxDeepEngineParameters params, boolean is_padded) {
    KernelBlock loopback = addKernel(
        new LoopbackKernel(
          makeKernelParameters(MaxDeepManager.LOOPBACK_KERNEL_NAME)));
     
    if (!is_padded) {
      ManagerUtils.addLinearStreamFromLMemToKernel(
          group, loopback, LMEM_INP_NAME, LoopbackKernel.INP_NAME);
      ManagerUtils.addLinearStreamFromLMemToKernel(
          group, loopback, LMEM_WGT_NAME, LoopbackKernel.WGT_NAME);
      ManagerUtils.addLinearStreamFromKernelToLMem(
          group, loopback, LoopbackKernel.OUT_NAME, LMEM_OUT_NAME);
    } else {
      loopback.getInput(LoopbackKernel.INP_NAME) <==
        unpadding_inp.getOutput(UnpaddingKernel.OUT_NAME);
      loopback.getInput(LoopbackKernel.WGT_NAME) <==
        unpadding_wgt.getOutput(UnpaddingKernel.OUT_NAME);
      padding.getInput(PaddingKernel.INP_NAME) <==
        loopback.getOutput(LoopbackKernel.OUT_NAME);
    }

    loopback.setClock(clk);
  }

  /**
   * Initialilze a kernel block for MultArrayKernel.
   * @author Ruizhe Zhao
   * @since 19/05/2017
   */
  private void initializeMultArrayKernel(MaxDeepEngineParameters params) {
    logMsg("Initializing MULT_ARRAY kernel ...");
    logMsg("FREQ:      %d", params.getFreq());
    logMsg("NUM_PIPES: %d", params.getNumPipes());

    KernelBlock multArray = addKernel(
        new MultArrayKernel(
          makeKernelParameters(MaxDeepManager.MULT_ARRAY_KERNEL_NAME),
          params.getNumPipes(),
          params.getDbg()));

    // By defaut, multArray will be connected directly to padding
    // and unpadding kernels
    multArray.getInput(MultArrayKernel.INP_NAME) <==
      unpadding_inp.getOutput(UnpaddingKernel.OUT_NAME);
    multArray.getInput(MultArrayKernel.WGT_NAME) <==
      unpadding_wgt.getOutput(UnpaddingKernel.OUT_NAME);
    padding.getInput(PaddingKernel.INP_NAME) <==
      multArray.getOutput(MultArrayKernel.OUT_NAME);

    multArray.setClock(clk);
  }

  /**
   * Create padding kernels and connect them to LMem.
   *
   * @author Ruizhe Zhao
   * @since 18/05/2017
   */
  private void initializePaddingKernels(MaxDeepEngineParameters params) {
    padding = addKernel(
        new PaddingKernel(
          makeKernelParameters(MaxDeepManager.PADDING_KERNEL_NAME),
          32, params.getDbg()));
    unpadding_inp = addKernel(
        new UnpaddingKernel(
          makeKernelParameters(MaxDeepManager.UNPADDING_INP_KERNEL_NAME),
          32, params.getDbg()));
    unpadding_wgt = addKernel(
        new UnpaddingKernel(
          makeKernelParameters(MaxDeepManager.UNPADDING_WGT_KERNEL_NAME),
          32, params.getDbg()));

    ManagerUtils.addLinearStreamFromLMemToKernel(
        group, unpadding_inp, LMEM_INP_NAME, UnpaddingKernel.INP_NAME);
    ManagerUtils.addLinearStreamFromLMemToKernel(
        group, unpadding_wgt, LMEM_WGT_NAME, UnpaddingKernel.INP_NAME);
    ManagerUtils.addLinearStreamFromKernelToLMem(
        group, padding, PaddingKernel.OUT_NAME, LMEM_OUT_NAME);

    // Don't need to explicitly set the clock source for padding kernels
    // padding.setClock(clk);
    // unpadding_inp.setClock(clk);
    // unpadding_wgt.setClock(clk);
  }

  /**
   * Create an engine interface for the loopback test.
   *
   * @author Ruizhe Zhao
   * @since 16/05/2017
   * @param ei Engine interface to be updated
   */
  private void initializeEngineInterfaceForLoopback(EngineInterface ei) {
    InterfaceParam N =
      ei.addParam(
          "num_elems",
          CPUTypes.INT32,
          "Number of elements to be transferred");
    InterfaceParam ZERO = ei.addConstant(0);
    InterfaceParam sizeInBytes = N * CPUTypes.UINT32.sizeInBytes();

    ei.setTicks(MaxDeepManager.LOOPBACK_KERNEL_NAME, N);
    ei.setLMemLinear(LMEM_INP_NAME, ZERO, sizeInBytes);
    ei.setLMemLinear(LMEM_WGT_NAME, sizeInBytes, sizeInBytes);
    ei.setLMemLinear(LMEM_OUT_NAME, 2 * sizeInBytes, sizeInBytes);
  }

  /**
   * Create LOOPBACK_PADDED related configuration in the engine interface.
   *
   * @author Ruizhe Zhao
   * @since 18/05/2017
   */
  private void initializeEngineInterfaceForLoopbackPadded(EngineInterface ei) {
    InterfaceParam N =
      ei.addParam(
          "num_elems",
          CPUTypes.INT64,
          "Number of elements to be transferred");
    InterfaceParam ZERO = ei.addConstant(0);
    InterfaceParam sizeInBytes = N * CPUTypes.UINT32.sizeInBytes();
    InterfaceParam burstAlignedNumOfElems =
      getBurstAlignedNumOfElems(N, CPUTypes.UINT32.sizeInBytes(), ei);
    InterfaceParam burstAlignedSizeInBytes = burstAlignedNumOfElems * CPUTypes.UINT32.sizeInBytes();

    ei.setTicks(LOOPBACK_KERNEL_NAME, N);
    ei.setTicks(PADDING_KERNEL_NAME, burstAlignedNumOfElems);
    ei.setTicks(UNPADDING_INP_KERNEL_NAME, burstAlignedNumOfElems);
    ei.setTicks(UNPADDING_WGT_KERNEL_NAME, burstAlignedNumOfElems);

    ei.setScalar(PADDING_KERNEL_NAME,       PaddingKernel.SCALAR_NUM_INP,        N);
    ei.setScalar(PADDING_KERNEL_NAME,       PaddingKernel.SCALAR_TOTAL_CYCLES,   burstAlignedNumOfElems);
    ei.setScalar(UNPADDING_INP_KERNEL_NAME, UnpaddingKernel.SCALAR_NUM_INP,      N);
    ei.setScalar(UNPADDING_INP_KERNEL_NAME, UnpaddingKernel.SCALAR_TOTAL_CYCLES, burstAlignedNumOfElems);
    ei.setScalar(UNPADDING_WGT_KERNEL_NAME, UnpaddingKernel.SCALAR_NUM_INP,      N);
    ei.setScalar(UNPADDING_WGT_KERNEL_NAME, UnpaddingKernel.SCALAR_TOTAL_CYCLES, burstAlignedNumOfElems);

    ei.setLMemLinear(LMEM_INP_NAME, ZERO, burstAlignedSizeInBytes);
    ei.setLMemLinear(LMEM_WGT_NAME, burstAlignedSizeInBytes, burstAlignedSizeInBytes);
    ei.setLMemLinear(LMEM_OUT_NAME, 2 * burstAlignedSizeInBytes, burstAlignedSizeInBytes);
  }

  /**
   * Create MULT_ARRAY related configuration in the engine interface.
   *
   * @author Ruizhe Zhao
   * @since 19/05/2017
   */
  private void initializeEngineInterfaceForMultArray(
      EngineInterface ei, MaxDeepEngineParameters params) {
    InterfaceParam N =
      ei.addParam(
          "num_elems",
          CPUTypes.INT64,
          "Number of elements to be transferred to the INP stream");
    InterfaceParam ZERO = ei.addConstant(0);

    InterfaceParam inpNumElems = N;
    InterfaceParam wgtNumElems = N * params.getNumPipes();

    InterfaceParam burstAlignedInpNumOfElems =
      getBurstAlignedNumOfElems(inpNumElems, CPUTypes.UINT32.sizeInBytes(), ei);
    InterfaceParam burstAlignedInpSizeInBytes = burstAlignedInpNumOfElems * CPUTypes.UINT32.sizeInBytes();
    
    InterfaceParam burstAlignedWgtNumOfElems =
      getBurstAlignedNumOfElems(wgtNumElems, CPUTypes.UINT32.sizeInBytes(), ei);
    InterfaceParam burstAlignedWgtSizeInBytes = burstAlignedWgtNumOfElems * CPUTypes.UINT32.sizeInBytes();

    ei.setTicks(MULT_ARRAY_KERNEL_NAME, N);
    ei.setTicks(PADDING_KERNEL_NAME, burstAlignedInpNumOfElems);
    ei.setTicks(UNPADDING_INP_KERNEL_NAME, burstAlignedInpNumOfElems);
    ei.setTicks(UNPADDING_WGT_KERNEL_NAME, burstAlignedWgtNumOfElems);

    ei.setScalar(PADDING_KERNEL_NAME, PaddingKernel.SCALAR_NUM_INP, inpNumElems);
    ei.setScalar(PADDING_KERNEL_NAME, PaddingKernel.SCALAR_TOTAL_CYCLES, burstAlignedInpNumOfElems);
    ei.setScalar(UNPADDING_INP_KERNEL_NAME, UnpaddingKernel.SCALAR_NUM_INP, inpNumElems);
    ei.setScalar(UNPADDING_INP_KERNEL_NAME, UnpaddingKernel.SCALAR_TOTAL_CYCLES, burstAlignedInpNumOfElems);
    ei.setScalar(UNPADDING_WGT_KERNEL_NAME, UnpaddingKernel.SCALAR_NUM_INP, wgtNumElems);
    ei.setScalar(UNPADDING_WGT_KERNEL_NAME, UnpaddingKernel.SCALAR_TOTAL_CYCLES, burstAlignedWgtNumOfElems);

    ei.setLMemLinear(LMEM_INP_NAME, ZERO, burstAlignedInpSizeInBytes);
    ei.setLMemLinear(LMEM_WGT_NAME, burstAlignedInpSizeInBytes, burstAlignedWgtSizeInBytes);
    ei.setLMemLinear(LMEM_OUT_NAME, burstAlignedInpSizeInBytes + burstAlignedWgtSizeInBytes,
        burstAlignedInpSizeInBytes);
  }

  /**
   * Get the burst aligned number of elements from the current number of elements and
   * the size of the data type in bytes.
   *
   * @author Ruizhe Zhao
   * @since 19/05/2017
   *
   * @param numOfElems number of elements of the original array
   * @param sizeInBytes size of an array element in bytes
   * @param ei engine interface to be used
   * @return number of elements in the burst aligned array
   */
  private InterfaceParam getBurstAlignedNumOfElems(InterfaceParam numOfElems, int sizeInBytes,
      EngineInterface ei) {
    InterfaceParam burstSize = ei.addConstant(384);
    InterfaceParam totalSizeInBytes = numOfElems * sizeInBytes;
    InterfaceParam burstAlignedTotalSizeInBytes =
      InterfaceMath
      .ceil(
          totalSizeInBytes.cast(CPUTypes.DOUBLE) /
          burstSize.cast(CPUTypes.DOUBLE))
      .cast(CPUTypes.INT64) * burstSize;
    InterfaceParam burstAlignedNumOfElems =
      burstAlignedTotalSizeInBytes / sizeInBytes;
    return burstAlignedNumOfElems.cast(CPUTypes.INT64);
  }

  public EngineInterface interfaceDefault(MaxDeepEngineParameters params) {
    EngineInterface ei = new EngineInterface();

    if (params.getDesignName().equals("LOOPBACK"))
      initializeEngineInterfaceForLoopback(ei);
    else if (params.getDesignName().equals("LOOPBACK_PADDED"))
      initializeEngineInterfaceForLoopbackPadded(ei);
    else if (params.getDesignName().equals("MULT_ARRAY"))
      initializeEngineInterfaceForMultArray(ei, params);
    else
      throw new IllegalArgumentException(
          String.format("Design name \"%s\" cannot be recognized",
            params.getDesignName()));

    ManagerUtils.ignoreLMemStreams(ei);
    return ei;
  }

  public static void main(String [] args) {
    MaxDeepEngineParameters params = new MaxDeepEngineParameters(args);
    MaxDeepManager manager = new MaxDeepManager(params);

    manager.createSLiCinterface(ManagerUtils.dramWrite(manager, manager.iface));
    manager.createSLiCinterface(ManagerUtils.dramRead(manager, manager.iface));
    manager.createSLiCinterface(manager.interfaceDefault(params));

    if (params.getDbg())
      ManagerUtils.debug(manager);
    // NOTE: Please don't uncomment this line of code until you know
    // what you are doing!!!
    // ManagerUtils.setDRAMMaxDeviceFrequency(manager, params);

    /**
     * NOTE: Set the DRAM frequency to 400MHz to avoid performance
     * bottleneck at the memory controller.
     */
    ManagerUtils.setDRAMFreq(manager, params, 400);
    if (params.getFreq() > 150)
      ManagerUtils.setFullBuild(manager, BuildConfig.Effort.HIGH, 6, 6);
    else if (params.getFreq() >= 120)
      ManagerUtils.setFullBuild(manager, BuildConfig.Effort.MEDIUM, 4, 4);
    else
      // Don't set it to LOW effort, and remain at least two CTs,
      // or it will definitely fail.
      ManagerUtils.setFullBuild(manager, BuildConfig.Effort.MEDIUM, 2, 2);

    manager.build();
  }
}
