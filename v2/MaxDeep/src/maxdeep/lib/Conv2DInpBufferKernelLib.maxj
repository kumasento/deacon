package maxdeep.lib;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.*;
import com.maxeler.maxcompiler.v2.utils.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;

import java.util.*;

public class Conv2DInpBufferKernelLib extends KernelLib {

  private int maxHeight;
  private int maxWidth;
  private int maxWidthFolded;
  private int numPipes;

  private DFEType indexType;
  private DFEType valueType;
  private DFEVectorType<DFEVar> vectorType;
  private DFEType addrType;

  private DFEVector<DFEVar> inp;
  private DFEVector<DFEVar> out;

  private DFEVar height;
  private DFEVar width;
  private DFEVar widthFolded;
  private DFEVar numOfChannels;
  private DFEVar h;
  private DFEVar w;
  private DFEVar c;
  
  private CounterChain chain;

  private Memory<DFEVector<DFEVar>> memory;
  
  public Conv2DInpBufferKernelLib(KernelLib owner, int maxHeight, int maxWidth, int numPipes,
      DFEType scalarType, boolean dbg) {

    super(owner);

    this.maxHeight = maxHeight;
    this.maxWidth = maxWidth;
    this.numPipes = numPipes;
    this.maxWidthFolded = maxWidth / numPipes;

    initTypes(scalarType);
    initScalars();
    initStreams();
    initCounters();
    initMemory();

    DFEVar addr = (h * width + w).cast(addrType);
    DFEVector<DFEVar> port = this.memory.port(
        addr,
        this.inp,
        this.c === 0,
        Mem.RamWriteMode.WRITE_FIRST);
    this.out <== port;

    if (dbg) {
      // debug.simPrintf("CONV2D_INP_BUFFER\n");
      // debug.simPrintf("%u %u %u\n", addr, this.inp, this.out);
    }
  }

  public void setInput(DFEVector<DFEVar> inp) {
    this.inp <== inp;
  }

  public void setHeight(DFEVar height) {
    this.height <== height;
  }

  public void setWidth(DFEVar width) {
    this.width <== width;
  }

  public void setNumOfChannels(DFEVar numOfChannels) {
    this.numOfChannels <== numOfChannels;
  }

  public DFEVector<DFEVar> getOutput() {
    return this.out;
  }

  private void initTypes(DFEType scalarType) {
    indexType = dfeUInt(32);
    valueType = scalarType;
    vectorType = new DFEVectorType<DFEVar>(scalarType, this.numPipes);
    addrType = dfeUInt(MathUtils.bitsToAddress(maxHeight * maxWidthFolded));
  }

  private void initScalars() {
    height = indexType.newInstance(this);
    width = indexType.newInstance(this);
    widthFolded = width / numPipes;
    numOfChannels = indexType.newInstance(this);
  }

  private void initStreams() {
    inp = vectorType.newInstance(this);
    out = vectorType.newInstance(this);
  }

  private void initCounters() {
    chain = control.count.makeCounterChain();
    c = chain.addCounter(numOfChannels, 1).cast(indexType);
    h = chain.addCounter(height, 1).cast(indexType);
    w = chain.addCounter(widthFolded, 1).cast(indexType);
  }

  private void initMemory() {
    this.memory = mem.alloc(this.vectorType, this.maxHeight * this.maxWidthFolded);
  }

}
