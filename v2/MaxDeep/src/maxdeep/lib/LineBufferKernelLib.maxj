package maxdeep.lib;

import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;

/**
 * This is a kernel for integrating line buffer with your design.
 *
 * Usage:
 * 1. specify maximum height and width, and also the base DFEType
 * 2. setup input stream, current height, width, and capacity of the buffer
 * 3. setup connections from the output stream and the valid signal
 *
 * @author Ruizhe Zhao
 * @since 24/04/2017
 */
public class LineBufferKernelLib extends KernelLib {

  private int maxHeight;
  private int maxWidth;
  private int maxWidthFolded;
  private int numPipes;

  private DFEType scalarType;
  private DFEVectorType<DFEVar> valueType;
  private DFEType indexType;

  private DFEVar height;
  private DFEVar width;
  private DFEVar widthFolded;
  private DFEVar capacity;
  private DFEVar capacityFolded;

  private DFEVector<DFEVar> buf;
  private DFEVar vld;
  private DFEVar idx;

  /**
   * Constructor.
   *
   * Folded line buffer: enable multiple elements input and output
   * in one cycle
   */
  public LineBufferKernelLib(KernelLib owner, int maxHeight, int maxWidth, int numPipes, DFEType type) {
    super(owner);

    this.numPipes = numPipes;
    this.maxHeight = maxHeight;
    this.maxWidth = maxWidth;
    this.maxWidthFolded = maxWidth / numPipes;

    scalarType = type;
    valueType = new DFEVectorType<DFEVar>(type, numPipes);
    indexType = dfeInt(32);

    height = indexType.newInstance(this);
    width = indexType.newInstance(this);
    capacity = indexType.newInstance(this);
    widthFolded = width / numPipes;
    capacityFolded = capacity / numPipes;

    buf = valueType.newInstance(this);
    idx = control.count.simpleCounter(32, capacityFolded.cast(dfeUInt(32))).cast(indexType);
    vld = idx >= (widthFolded * (height - 1));
  }

  public void setInput(DFEVector<DFEVar> inp) { buf <== inp; }

  public void setHeight(DFEVar height) { this.height <== height; }

  public void setWidth(DFEVar width) { this.width <== width; }

  /**
   * Capacity should not be smaller than height * width
   */
  public void setCapacity(DFEVar capacity) { this.capacity <== capacity; }

  @Deprecated 
  public DFEVar getValid() { return vld; }

  public DFEVector<DFEVar> getOutput() {
    DFEVectorType<DFEVar> outVecType =
      new DFEVectorType<DFEVar>(scalarType, maxHeight * numPipes);
    DFEVector<DFEVar> outVec = outVecType.newInstance(this);

    for (int j = 0; j < maxHeight; j ++) {
      DFEVector<DFEVar> outVecRead = getOutputVectorAt(maxHeight - j - 1);
      for (int i = 0; i < numPipes; i ++) {
        outVec[i * maxHeight + j] <== outVecRead[i];
      }
    }

    return outVec;
  }

  private DFEVector<DFEVar> getOutputVectorAt(int i) {
    if (i == 0)
      return buf;

    DFEVar index = constant.var(i).cast(indexType);
    DFEVar offset = index * (- widthFolded);
    int maxOffset = - maxWidthFolded * maxHeight;
    DFEVector<DFEVar> readBufByOffset = stream.offset(
        buf,
        offset,
        maxOffset,
        0);
    return readBufByOffset;
  }
}
