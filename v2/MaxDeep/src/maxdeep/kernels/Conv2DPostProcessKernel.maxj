package maxdeep.kernels;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.*;
import com.maxeler.maxcompiler.v2.utils.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;

import maxdeep.lib.*;

import java.util.*;

public class Conv2DPostProcessKernel extends Kernel {

  public static final String INP_NAME = "CONV2D_POST_PROC_KERNEL_INP";
  public static final String OUT_NAME = "CONV2D_POST_PROC_KERNEL_OUT";

  public static final String SCALAR_OUT_HEIGHT_NAME =
    "CONV2D_POST_PROC_KERNEL_SCALAR_OUT_HEIGHT";
  public static final String SCALAR_OUT_WIDTH_NAME =
    "CONV2D_POST_PROC_KERNEL_SCALAR_OUT_WIDTH";
  public static final String SCALAR_NUM_OF_CHANNELS_NAME =
    "CONV2D_POST_PROC_KERNEL_SCALAR_NUM_OF_CHANNELS";
  public static final String SCALAR_NUM_OF_FILTERS_NAME =
    "CONV2D_POST_PROC_KERNEL_SCALAR_NUM_OF_FILTERS";

  /**
   * Constants
   */
  private int maxOutHeight;
  private int maxOutWidth;
  private int maxNumOfChannels;
  private int maxNumOfFilters;
  private int partialResultBufferSize;
  private int numOfFilterPipes;

  /**
   * Types
   */
  private DFEType indexType;
  private DFEType valueType;
  private DFEType addrType;
  private DFEVectorType<DFEVar> vectorType;

  /**
   * Scalars
   */
  private DFEVar outHeight;
  private DFEVar outWidth;
  private DFEVar numOfChannels;
  private DFEVar numOfFilters;

  /**
   * Counters
   */
  private DFEVar h;
  private DFEVar w;
  private DFEVar f;
  private DFEVar c;
  private DFEVar t;

  /**
   * Streams
   */
  private DFEVector<DFEVar> inp;
  private DFEVector<DFEVar> out;

  /**
   * Memory
   */
  private List<Memory<DFEVar>> partialResultBuffers;

  /**
   * Constructor.
   *
   * @author Ruizhe Zhao
   * @since 28/05/2017
   *
   * @param params kernel parameter
   * @param maxOutHeight maximum output fmap height
   * @param maxOutWidth maximum output fmap width
   * @param maxNumOfChannels maximum input fmap channel number
   * @param maxNumOfFilters maximum output fmap filter number
   * @param numOfFilterPipes number of pipes along filters
   */
  public Conv2DPostProcessKernel(KernelParameters params,
      int maxOutHeight, int maxOutWidth,
      int maxNumOfChannels, int maxNumOfFilters,
      int numOfFilterPipes,
      boolean dbg) {
    super(params);

    this.maxOutHeight = maxOutHeight;
    this.maxOutWidth = maxOutWidth;
    this.maxNumOfChannels = maxNumOfChannels;
    this.maxNumOfFilters = maxNumOfFilters;
    this.numOfFilterPipes = numOfFilterPipes;
    this.partialResultBufferSize =
      maxNumOfFilters * maxOutHeight * maxOutWidth / numOfFilterPipes;

    // logMsg("Partial Result Buffer Size: %d (%d)", this.partialResultBufferSize,
    //     MathUtils.bitsToAddress(this.partialResultBufferSize));

    initTypes();
    initScalars();
    initCounters();
    initStreams();
    initBuffer();

    DFEVar outSize = this.outHeight * this.outWidth;

    DFEVar readAddr = (this.f * outSize + this.h * this.outWidth + this.w)
      .cast(this.addrType);
    DFEVector<DFEVar> readValue = this.vectorType.newInstance(this);
    for (int i = 0; i < this.numOfFilterPipes; i ++)
      readValue[i] <== this.partialResultBuffers.get(i).read(readAddr);
    
    DFEVector<DFEVar> result = readValue + this.inp;
    this.out <== result;

    int writeLatency = 3;
    DFEVar writeAddr = stream.offset(readAddr, -writeLatency);
    DFEVector<DFEVar> writeValue = stream.offset(result, -writeLatency);
    for (int i = 0; i < numOfFilterPipes; i ++)
      this.partialResultBuffers[i].write(
          writeAddr, writeValue[i], this.t >= writeLatency);

    if (dbg) {
      debug.simPrintf("CONV2D_POST_PROC (%d %d %d %d)\n", c, f, h, w);
      debug.simPrintf("read: %u %KObj%\n", readAddr.cast(dfeUInt(32)), readValue);
      debug.simPrintf("write: %u %KObj%\n", writeAddr.cast(dfeUInt(32)), writeValue);
      debug.simPrintf("result: %KObj% + %KObj% = %KObj%\n", inp, readValue, out);
    }
  }

  private void initTypes() {
    indexType = dfeUInt(32);
    valueType = dfeUInt(32);
    addrType = dfeUInt(MathUtils.bitsToAddress(partialResultBufferSize));
    vectorType = new DFEVectorType<DFEVar>(valueType, numOfFilterPipes);
  }

  private void initScalars() {
    this.outHeight     = io.scalarInput(SCALAR_OUT_HEIGHT_NAME, indexType);
    this.outWidth      = io.scalarInput(SCALAR_OUT_WIDTH_NAME, indexType);
    this.numOfChannels = io.scalarInput(SCALAR_NUM_OF_CHANNELS_NAME, indexType);
    this.numOfFilters  = io.scalarInput(SCALAR_NUM_OF_FILTERS_NAME, indexType);
  }

  private void initCounters() {
    CounterChain chain = control.count.makeCounterChain();
    this.c = chain.addCounter(this.numOfChannels, 1).cast(indexType);
    this.f = chain.addCounter(this.numOfFilters / this.numOfFilterPipes, 1).cast(indexType);
    this.h = chain.addCounter(this.outHeight, 1).cast(indexType);
    this.w = chain.addCounter(this.outWidth, 1).cast(indexType);

    this.t = control.count.simpleCounter(32);
  }

  private void initStreams() {
    this.inp = io.input(INP_NAME, vectorType);
    this.out = vectorType.newInstance(this);

    io.output(OUT_NAME, this.out, vectorType, this.c === this.numOfChannels - 1);
  }

  private void initBuffer() {
    this.partialResultBuffers = new ArrayList<Memory<DFEVar>>();
    for (int i = 0; i < this.numOfFilterPipes; i ++)
      this.partialResultBuffers.add(
          mem.alloc(valueType, partialResultBufferSize));
  }

}
