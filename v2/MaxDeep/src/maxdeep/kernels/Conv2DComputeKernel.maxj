package maxdeep.kernels;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.*;
import com.maxeler.maxcompiler.v2.utils.*;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;

import maxdeep.lib.*;

import java.util.*;

/**
 * Kernel aims at computing the core 2D convolution.
 *
 * @author Ruizhe Zhao
 * @since 25/05/2017
 */
public class Conv2DComputeKernel extends Kernel {

  public static final String INP_NAME = "CONV2D_COMPUTE_KERNEL_INP";
  public static final String WGT_NAME = "CONV2D_COMPUTE_KERNEL_WGT";
  public static final String OUT_NAME = "CONV2D_COMPUTE_KERNEL_OUT";

  public static final String SCALAR_OUT_HEIGHT_NAME =
    "CONV2D_COMPUTE_SCALAR_OUT_HEIGHT";
  public static final String SCALAR_OUT_WIDTH_NAME =
    "CONV2D_COMPUTE_SCALAR_OUT_WIDTH";
  public static final String SCALAR_NUM_OF_FILTERS_NAME =
    "CONV2D_COMPUTE_SCALAR_NUM_OF_FILTERS";

  private DFEType scalarType;
  private DFEType indexType;
  private DFEVectorType<DFEVar> inpType;
  private DFEVectorType<DFEVar> wgtType;
  private DFEVectorType<DFEVar> outType;
  private DFEVectorType<DFEVar> wgtPartialType;
  private DFEVectorType<DFEVar> outPartialType;

  /**
   * Counters.
   */
  private DFEVar h;
  private DFEVar w;
  private DFEVar f;
  private DFEVar p;

  /**
   * Scalars.
   */
  private DFEVar outHeight;
  private DFEVar outWidth;
  private DFEVar numOfFilters;

  /**
   * Constant parameters.
   */
  private int kernelHeight;
  private int kernelWidth;
  private int kernelSize;
  private int numOfFilterPipes;
  private int numOfFilterPumps;
  private int bitWidth;

  /**
   * Streams.
   */
  private DFEVector<DFEVar> inp;
  private DFEVector<DFEVar> wgt;
  private DFEVector<DFEVar> out;

  /**
   * Constructor.
   *
   * @author Ruizhe Zhao
   * @since 25/05/2017
   *
   * @param params kernel parameters
   * @param kernelHeight height of the kernel
   * @param kernelWidth width of the  kernel
   * @param numOfFilterPipes pipes along the filter axis
   * @param numOfFilterPumps multi-pumping factor
   * @param dbg debugging flag
   */
  public Conv2DComputeKernel(
      KernelParameters params,
      int kernelHeight,
      int kernelWidth,
      int numOfFilterPipes,
      int numOfFilterPumps,
      int bitWidth,
      double dspFactor,
      boolean dbg)
  {
    super(params);

    optimization.pushDSPFactor(dspFactor);

    this.bitWidth = bitWidth;
    this.kernelHeight = kernelHeight;
    this.kernelWidth = kernelWidth;
    this.kernelSize = kernelHeight * kernelWidth;
    this.numOfFilterPipes = numOfFilterPipes;
    this.numOfFilterPumps = numOfFilterPumps;

    initTypes();
    initScalars();
    initCounters();
    initStreams();

    DFEVector<DFEVar> outPartial = this.compute(inp, wgt);

    int outChunkSize = numOfFilterPipes / numOfFilterPumps;
    for (int i = 0; i < numOfFilterPumps; i ++) {
      DFEVector<DFEVar> currOutPartial =
        stream.offset(outPartial, - (numOfFilterPumps - i - 1));
      
      for (int j = 0; j < outChunkSize; j ++) {
        this.out[i * outChunkSize + j] <==
          currOutPartial[j];
      }
    }

    optimization.popDSPFactor();

    if (dbg) {
      DFEVar t = control.count.simpleCounter(32);
      debug.simPrintf("CONV2D_COMPUTE_KERNEL (%d)\n", t);
      debug.simPrintf("inp: %KObj%\n", inp);
      debug.simPrintf("wgt: %KObj%\n", wgt);
      debug.simPrintf("out: %KObj%\n", out);
    }
  }

  private void initTypes() {
    this.indexType = dfeUInt(32);
    this.scalarType = dfeUInt(this.bitWidth);
    this.inpType = new DFEVectorType<DFEVar>(
        scalarType, this.kernelSize);
    this.wgtType = new DFEVectorType<DFEVar>(
        scalarType, this.kernelSize * this.numOfFilterPipes);
    this.wgtPartialType = new DFEVectorType<DFEVar>(
        scalarType, this.kernelSize * this.numOfFilterPipes / this.numOfFilterPumps);
    this.outType = new DFEVectorType<DFEVar>(
        scalarType, this.numOfFilterPipes);
    this.outPartialType = new DFEVectorType<DFEVar>(
        scalarType, this.numOfFilterPipes / this.numOfFilterPumps);
  }

  private void initScalars() {
    this.outHeight    = io.scalarInput(SCALAR_OUT_HEIGHT_NAME, indexType);
    this.outWidth     = io.scalarInput(SCALAR_OUT_WIDTH_NAME, indexType);
    this.numOfFilters = io.scalarInput(SCALAR_NUM_OF_FILTERS_NAME, indexType);
  }

  private void initCounters() {
    CounterChain chain = control.count.makeCounterChain();
    this.f = chain.addCounter(this.numOfFilters, this.numOfFilterPipes)
      .cast(this.indexType);
    this.h = chain.addCounter(this.outHeight, 1).cast(this.indexType);
    this.w = chain.addCounter(this.outWidth, 1).cast(this.indexType);
    
    if (this.numOfFilterPumps > 1) {
      this.p = chain.addCounter(this.numOfFilterPumps, 1);
      this.p = this.p.cast(dfeUInt(
            MathUtils.bitsToAddress(this.numOfFilterPumps)));
    } else { 
      this.p = constant.var(0);
    }
  }

  private void initStreams() {
    inp = io.input(INP_NAME, this.inpType, this.p === 0);
    wgt = io.input(WGT_NAME, this.wgtType, this.p === 0 & this.h === 0 & this.w === 0);
    out = this.outType.newInstance(this);

    io.output(OUT_NAME, out, this.outType,
      this.p === this.numOfFilterPumps - 1);
  }

  private DFEVector<DFEVar> getCurrWgtChunk() {
    if (this.numOfFilterPumps == 1)
      return this.wgt;

    DFEVector<DFEVar> wgtChunk =
        this.wgtPartialType.newInstance(this);
    int chunkSize =
        this.kernelSize *
        this.numOfFilterPipes / this.numOfFilterPumps;

    for (int i = 0; i < chunkSize; i ++) {
      List<DFEVar> candidates = new ArrayList<DFEVar>();
      for (int p = 0; p < numOfFilterPumps; p ++)
        candidates.add(this.wgt[i + p * chunkSize]);

      wgtChunk[i] <==
        control.mux(this.p, candidates);
    }

    return wgtChunk;
  }

  /**
   * Compute conv2d in parallel.
   *
   * @author Ruizhe Zhao
   * @since 25/05/2017
   *
   * @param inp input vector (K * K)
   * @param wgt weight vector (P * K * K)
   * @return output vector (P)
   */
  private DFEVector<DFEVar> compute(DFEVector<DFEVar> inp,
      DFEVector<DFEVar> wgt) {
    
    DFEVector<DFEVar> out = this.outPartialType.newInstance(this);
    DFEVector<DFEVar> wgtChunk = getCurrWgtChunk();
    DFEVectorType<DFEVar> wgtKnlType = 
      new DFEVectorType<DFEVar>(this.scalarType, this.kernelSize);
    
    for (int i = 0; i < this.numOfFilterPipes / this.numOfFilterPumps; i ++) {
      DFEVector<DFEVar> wgtKnl = wgtKnlType.newInstance(this);
      for (int j = 0; j < this.kernelSize; j ++)
        wgtKnl[j] <== wgtChunk[i * this.kernelSize + j];

      TwoDimConvKernelLib conv = new TwoDimConvKernelLib(
          this, this.kernelHeight, this.kernelWidth,
          this.scalarType);

      conv.setInput(inp);
      conv.setWeight(wgtKnl);
      out[i] <== conv.getOutput();
    }

    return out;
  }

}
