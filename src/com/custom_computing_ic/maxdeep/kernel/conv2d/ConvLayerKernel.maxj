/**
 *
 */
package com.custom_computing_ic.maxdeep.kernel.conv2d;

import com.custom_computing_ic.maxdeep.kernel.conv2d.ConvLayerParameters.CompSeq;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelBase;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelComponent;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

/**
 * This kernel implements a full convolution layer.
 * 
 * @author Ruizhe Zhao
 * 
 */
public class ConvLayerKernel extends KernelComponent {

  private final DFEVectorType<DFEVar> ifmapVecT, coeffVecT, ofmapVecT;
  private final DFEType               scalarT;
  private final DFEVector<DFEVar>     ifmap, coeff, ofmap;
  private final ConvLayerParameters   cp;
  
  /* counters */
  private DFEVar h;
  private DFEVar w;
  private DFEVar c;
  private DFEVar f;

  public ConvLayerKernel(KernelBase<?> owner,
      ConvLayerParameters convParams, DFEType scalarT) {
    super(owner);

    this.cp = convParams;

    /* scalar type */
    this.scalarT = scalarT;

    /* vector type */
    this.ifmapVecT = new DFEVectorType<DFEVar>(scalarT, getIfmapVecSize());
    this.coeffVecT = new DFEVectorType<DFEVar>(scalarT, getCoeffVecSize());
    this.ofmapVecT = new DFEVectorType<DFEVar>(scalarT, getOfmapVecSize());

    /* streams */
    this.ifmap = ifmapVecT.newInstance(owner);
    this.coeff = coeffVecT.newInstance(owner);
    this.ofmap = ofmapVecT.newInstance(owner);
    
    /* counters */
    initCounters();
  }

  public int getIfmapVecSize() {
    return cp.PC * cp.PK;
  }

  public int getCoeffVecSize() {
    return cp.PF * cp.PK * cp.K;
  }

  public int getOfmapVecSize() {
    return cp.PF * cp.PK;
  }

  public DFEVectorType<DFEVar> getIfmapVecT() {
    return this.ifmapVecT;
  }

  public DFEVectorType<DFEVar> getCoeffVecT() {
    return coeffVecT;
  }

  public DFEVectorType<DFEVar> getOfmapVecT() {
    return ofmapVecT;
  }
  
  public void setInputs(DFEVector<DFEVar> ifmap, DFEVector<DFEVar> coeff) {
    this.ifmap <== ifmap;
    this.coeff <== coeff;
  }
  
  public DFEVector<DFEVar> getOfmap() {
    return this.ofmap;
  }
  
  private void initCounters() {
    CounterChain chain = getOwner().control.count.makeCounterChain();
    
    if (cp.seq == CompSeq.CHANNEL_MAJOR) {
      c = chain.addCounter(cp.C, cp.PC);
      f = chain.addCounter(cp.F, cp.PF);
      h = chain.addCounter(cp.H, 1);
      w = chain.addCounter(cp.W, cp.PK);
    } else {
      throw new IllegalArgumentException(
          String.format(
              "Computation sequence %s has not been supported yet", cp.seq));
    }
  }
}
