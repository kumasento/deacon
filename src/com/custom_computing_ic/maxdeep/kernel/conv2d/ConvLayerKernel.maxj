/**
 *
 */
package com.custom_computing_ic.maxdeep.kernel.conv2d;

import com.custom_computing_ic.maxdeep.kernel.conv2d.lib.Conv2DKernel;
import com.custom_computing_ic.maxdeep.kernel.conv2d.lib.ConvLayerIfmapBuffer;
import com.custom_computing_ic.maxdeep.kernel.conv2d.lib.ConvLayerLineBuffer;
import com.custom_computing_ic.maxdeep.kernel.conv2d.lib.ConvLayerOfmapBuffer;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelBase;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelComponent;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

/**
 * This kernel implements a full convolution layer.
 * 
 * @author Ruizhe Zhao
 * 
 */
public class ConvLayerKernel extends KernelComponent {

  protected DFEVectorType<DFEVar>     ifmapVecT, coeffVecT, ofmapVecT;
  @SuppressWarnings("unused")
  protected final DFEType             scalarT;
  protected DFEVector<DFEVar>         ifmap;
  protected DFEVector<DFEVar>         coeff;
  protected DFEVector<DFEVar>         ofmap;
  protected final ConvLayerParameters cp;
  protected final String              prefix;

  /* counters */
  protected DFEVar                    h;
  protected DFEVar                    w;
  protected DFEVar                    c;
  protected DFEVar                    f;
  protected DFEVar                    oh, ow;

  protected ConvLayerIfmapBuffer      ibuf;
  protected ConvLayerLineBuffer       lbuf;
  protected ConvLayerOfmapBuffer      obuf;

  public ConvLayerKernel(KernelBase<?> owner, ConvLayerParameters convParams,
      DFEType scalarT) {
    this(owner, convParams, scalarT, convParams.name);
  }

  public ConvLayerKernel(KernelBase<?> owner, ConvLayerParameters convParams,
      DFEType scalarT, String prefix) {
    super(owner);

    this.cp = convParams;

    this.prefix = prefix;

    /* scalar type */
    this.scalarT = scalarT;

    /* streams */
    initStreams();

    /* counters */
    initCounters();

    /* compute */
    initConvLayer();
  }

  public void initStreams() {
    /* vector type */
    this.ifmapVecT = new DFEVectorType<DFEVar>(scalarT, getIfmapVecSize());
    this.coeffVecT = new DFEVectorType<DFEVar>(scalarT, getCoeffVecSize());
    this.ofmapVecT = new DFEVectorType<DFEVar>(scalarT, getOfmapVecSize());

    /* streams */
    this.ifmap = ifmapVecT.newInstance(getOwner());
    this.coeff = coeffVecT.newInstance(getOwner());
    this.ofmap = ofmapVecT.newInstance(getOwner());
  }

  public void initConvLayer() {
    /* ifmap buffer */
    ibuf = new ConvLayerIfmapBuffer(getOwner(), cp, scalarT);
    DFEVector<DFEVar> ifmapBufVec =
        ibuf.port(ifmap, getIfmapBufferAddr(), getIfmapBufferWriteEn());

    /* line buffer */
    lbuf = new ConvLayerLineBuffer(getOwner(), cp, scalarT);
    lbuf.setInput(ifmapBufVec);
    DFEVector<DFEVar> lineBufVec = lbuf.getOutputVec();

    /* conv2d */
    DFEVector<DFEVar> conv2dOfmap = null;
    if (cp.BW == 1) {
      BinarizedConv2DKernel conv2d = new BinarizedConv2DKernel(getOwner(), cp);
      conv2d.setInputs(lineBufVec, coeff);
      conv2dOfmap = conv2d.getOfmap();
    } else {
      Conv2DKernel conv2d = new Conv2DKernel(getOwner(), cp, scalarT);
      conv2d.setInputs(lineBufVec, coeff);
      conv2dOfmap = conv2d.getOfmap();
    }

    /* output buffer */
    obuf =
        new ConvLayerOfmapBuffer(getOwner(), cp,
            conv2dOfmap.getElementsAsList()[0].getType(), prefix);
    obuf.setReset(getOfmapReset());

    if (cp.BW == 1) {
      DFEVector<DFEVar> rawOfmap =
          obuf.port(conv2dOfmap, getOfmapBufferAddr(), getOfmapBufferWriteEn());
      for (int i = 0; i < rawOfmap.getSize(); i++)
        this.ofmap[i].connect((rawOfmap[i] > 1).cast(scalarT));

    } else {
      // TODO: change 1 here to be a real threshold value
      this.ofmap.connect(obuf.port(
          conv2dOfmap,
          getOfmapBufferAddr(),
          getOfmapBufferWriteEn()));
    }

    if (cp.dbg)
      debug.simPrintf("c = %d f = %d h = %d w = %d\n", c, f, h, w);
  }

  public DFEVar getOfmapReset() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return constant.var(0).cast(dfeBool());
      case FILTER_MAJOR:
        return c.eq(0);
      default:
        throw new IllegalArgumentException(String.format(
            "Computation sequence %s has not been supported yet",
            cp.seq));
    }
  }

  public DFEVar getOfmapEn() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return c.eq(cp.C / cp.PC - 1) & getOfmapBufferWriteEn();
      case FILTER_MAJOR:
        return c.eq(cp.C / cp.PC - 1) & getOfmapBufferWriteEn();
      default:
        throw new IllegalArgumentException(String.format(
            "Computation sequence %s has not been supported yet",
            cp.seq));
    }
  }

  public DFEVar getOfmapBufferWriteEn() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return (h >= (cp.K - 1)) & (w * cp.PK >= (cp.K - 1));

      case FILTER_MAJOR:
        return (h >= (cp.K - 1)) & (w * cp.PK >= (cp.K - 1));

      default:
        throw new IllegalArgumentException(String.format(
            "Computation sequence %s has not been supported yet",
            cp.seq));
    }
  }

  public DFEVar getOfmapBufferAddr() {
    return getOfmapBufferAddr(obuf.getAddrT());
  }

  public DFEVar getOfmapBufferAddr(DFEType addrT) {

    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return (f * (cp.OH * cp.OW / cp.PK) + oh * cp.OW / cp.PK + ow)
            .cast(addrT);

      case FILTER_MAJOR:
        return (oh * cp.OW / cp.PK + ow).cast(addrT);

      default:
        throw new IllegalArgumentException(String.format(
            "Computation sequence %s has not been supported yet",
            cp.seq));
    }
  }

  public DFEVar getIfmapEn() {
    return getIfmapBufferWriteEn();
  }

  public DFEVar getCoeffEn() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return (h.eq(0)) & (w.eq(0));
      case FILTER_MAJOR:
        return (h.eq(0)) & (w.eq(0));
      default:
        throw new IllegalArgumentException(String.format(
            "Computation sequence %s has not been supported yet",
            cp.seq));
    }
  }

  public int getIfmapVecSize() {
    return cp.PC * cp.PK;
  }

  public int getCoeffVecSize() {
    return cp.PF * cp.PC * cp.K * cp.K;
  }

  public int getOfmapVecSize() {
    return cp.PF * cp.PK;
  }

  public DFEVectorType<DFEVar> getIfmapVecT() {
    return this.ifmapVecT;
  }

  public DFEVectorType<DFEVar> getCoeffVecT() {
    return coeffVecT;
  }

  public DFEVectorType<DFEVar> getOfmapVecT() {
    return ofmapVecT;
  }

  public void setInputs(DFEVector<DFEVar> ifmap, DFEVector<DFEVar> coeff) {
    this.ifmap.connect(ifmap);
    this.coeff.connect(coeff);
  }

  public DFEVector<DFEVar> getOfmap() {
    return this.ofmap;
  }

  private void initCounters() {
    DFEType countT = dfeInt(32);
    CounterChain chain = getOwner().control.count.makeCounterChain();

    switch (cp.seq) {
      case CHANNEL_MAJOR:
        c = chain.addCounter(cp.C / cp.PC, 1).cast(countT);
        f = chain.addCounter(cp.F / cp.PF, 1).cast(countT);
        h = chain.addCounter(cp.H, 1).cast(countT);
        w = chain.addCounter(cp.W / cp.PK, 1).cast(countT);
        break;

      case FILTER_MAJOR:
        f = chain.addCounter(cp.F / cp.PF, 1).cast(countT);
        c = chain.addCounter(cp.C / cp.PC, 1).cast(countT);
        h = chain.addCounter(cp.H, 1).cast(countT);
        w = chain.addCounter(cp.W / cp.PK, 1).cast(countT);
        break;

      default:
        throw new IllegalArgumentException(String.format(
            "Computation sequence %s has not been supported yet",
            cp.seq));
    }

    if (cp.dbg) {
      debug.simPrintf("f = %d c = %d h = %d w = %d\n", f, c, h, w);
      debug.simPrintf("ifmapEn = %d\n", getIfmapEn());
      debug.simPrintf("ofmapEn = %d\n", getOfmapEn());
    }

    // counters for the output fmap
    oh = (h <= cp.K - 1) ? constant.var(0) : h - cp.K + 1;
    oh = oh.cast(countT);

    ow =
        (w * cp.PK < (cp.K - 1)) ? constant.var(0) : (w * cp.PK + 1 - cp.K)
            / cp.PK;
    ow = ow.cast(countT);

    if (cp.dbg) {
      debug.simPrintf("ofmap buffer addr = %KObj%\n", oh * cp.OW / cp.PK + ow);
    }
  }

  protected DFEVar getIfmapBufferAddr() {
    DFEVar addr;

    switch (cp.seq) {
      case CHANNEL_MAJOR:
        addr = h * (cp.W / cp.PK) + w;
        return addr.cast(ibuf.getAddrT());

      case FILTER_MAJOR:
        addr = c * cp.H * (cp.W / cp.PK) + h * (cp.W / cp.PK) + w;
        return addr.cast(ibuf.getAddrT());

      case PIXEL_MAJOR:
        addr = c * cp.H * (cp.W / cp.PK) + h * (cp.W / cp.PK) + w;
        return addr.cast(ibuf.getAddrT());

      default:
        throw new IllegalArgumentException(String.format(
            "Computation sequence %s has not been supported yet",
            cp.seq));
    }
  }

  protected DFEVar getIfmapBufferWriteEn() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return f.eq(0);

      case FILTER_MAJOR:
        return f.eq(0);

      default:
        throw new IllegalArgumentException(String.format(
            "Computation sequence %s has not been supported yet",
            cp.seq));
    }
  }

}
