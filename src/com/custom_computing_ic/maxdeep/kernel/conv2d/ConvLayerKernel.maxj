/**
 *
 */
package com.custom_computing_ic.maxdeep.kernel.conv2d;

import com.custom_computing_ic.maxdeep.kernel.conv2d.ConvLayerParameters.CompSeq;
import com.custom_computing_ic.maxdeep.kernel.conv2d.lib.Conv2DKernel;
import com.custom_computing_ic.maxdeep.kernel.conv2d.lib.ConvLayerIfmapBuffer;
import com.custom_computing_ic.maxdeep.kernel.conv2d.lib.ConvLayerLineBuffer;
import com.custom_computing_ic.maxdeep.kernel.conv2d.lib.ConvLayerOfmapBuffer;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelBase;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelComponent;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

/**
 * This kernel implements a full convolution layer.
 * 
 * @author Ruizhe Zhao
 * 
 */
public class ConvLayerKernel extends KernelComponent {

  private final DFEVectorType<DFEVar> ifmapVecT, coeffVecT, ofmapVecT;
  private final DFEType               scalarT;
  private final DFEVector<DFEVar>     ifmap, coeff, ofmap;
  private final ConvLayerParameters   cp;
  
  /* counters */
  private DFEVar h;
  private DFEVar w;
  private DFEVar c;
  private DFEVar f;
  
  private final ConvLayerIfmapBuffer ibuf; 
  
  private final ConvLayerLineBuffer lbuf;
  
  private final ConvLayerOfmapBuffer obuf;

  public ConvLayerKernel(KernelBase<?> owner,
      ConvLayerParameters convParams, DFEType scalarT) {
    super(owner);

    this.cp = convParams;

    /* scalar type */
    this.scalarT = scalarT;

    /* vector type */
    this.ifmapVecT = new DFEVectorType<DFEVar>(scalarT, getIfmapVecSize());
    this.coeffVecT = new DFEVectorType<DFEVar>(scalarT, getCoeffVecSize());
    this.ofmapVecT = new DFEVectorType<DFEVar>(scalarT, getOfmapVecSize());

    /* streams */
    this.ifmap = ifmapVecT.newInstance(owner);
    this.coeff = coeffVecT.newInstance(owner);
    this.ofmap = ofmapVecT.newInstance(owner);
    
    /* counters */
    initCounters();
    
    /* ifmap buffer */
    ibuf = new ConvLayerIfmapBuffer(getOwner(), cp, scalarT);
    DFEVector<DFEVar> ifmapBufVec =
      ibuf.port(ifmap, getIfmapBufferAddr(), getIfmapBufferWriteEn());
    
    /* line buffer */
    lbuf = new ConvLayerLineBuffer(getOwner(), cp, scalarT);
    lbuf.setInput(ifmapBufVec);
    DFEVector<DFEVar> lineBufVec = lbuf.getOutputVec();
    
    /* conv2d */
    Conv2DKernel conv2d = new Conv2DKernel(getOwner(), cp, scalarT);
    conv2d.setInputs(lineBufVec, coeff);
    DFEVector<DFEVar> conv2dOfmap = conv2d.getOfmap();
    
    /* output buffer */
    obuf = new ConvLayerOfmapBuffer(getOwner(), cp, scalarT);
    this.ofmap <==
      obuf.port(conv2dOfmap, getOfmapBufferAddr(), getOfmapBufferWriteEn());
    
    debug.simPrintf("c = %d f = %d h = %d w = %d\n", c, f, h, w);
  }
  
  public DFEVar getOfmapEn() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return c.eq(cp.C / cp.PC - 1) & getOfmapBufferWriteEn();
      default:
	      throw new IllegalArgumentException(
	          String.format(
	              "Computation sequence %s has not been supported yet", cp.seq));
    }
  }
  
  public DFEVar getOfmapBufferWriteEn() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return (h >= (cp.K - 1)) & (w * cp.PK >= (cp.K - 1));
      default:
	      throw new IllegalArgumentException(
	          String.format(
	              "Computation sequence %s has not been supported yet", cp.seq));
    }
  }
  
  public DFEVar getOfmapBufferAddr() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        DFEVar oh = (h <= cp.K - 1) ? constant.var(0) : h - cp.K + 1;
        DFEVar ow = (w * cp.PK < (cp.K - 1))
	        ? constant.var(0)
          : (w * cp.PK + 1 - cp.K) / cp.PK;
	      oh = oh.cast(f.getType());
	      ow = ow.cast(f.getType());
	      debug.simPrintf("addr = %KObj%\n", f * (cp.OH * cp.OW / cp.PK) +
	              oh * cp.OW / cp.PK +
	              ow);
	      return (f * (cp.OH * cp.OW / cp.PK) +
	              oh * cp.OW / cp.PK +
	              ow).cast(obuf.getAddrT());
      default:
	      throw new IllegalArgumentException(
	          String.format(
	              "Computation sequence %s has not been supported yet", cp.seq));
    }
  }
  
  public DFEVar getIfmapEn() {
    return getIfmapBufferWriteEn();
  }
  
  public DFEVar getCoeffEn() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return (h.eq(0)) & (w.eq(0));
      default:
	      throw new IllegalArgumentException(
	          String.format(
	              "Computation sequence %s has not been supported yet", cp.seq));
    }
  }

  public int getIfmapVecSize() {
    return cp.PC * cp.PK;
  }

  public int getCoeffVecSize() {
    return cp.PF * cp.PC * cp.K * cp.K;
  }

  public int getOfmapVecSize() {
    return cp.PF * cp.PK;
  }

  public DFEVectorType<DFEVar> getIfmapVecT() {
    return this.ifmapVecT;
  }

  public DFEVectorType<DFEVar> getCoeffVecT() {
    return coeffVecT;
  }

  public DFEVectorType<DFEVar> getOfmapVecT() {
    return ofmapVecT;
  }
  
  public void setInputs(DFEVector<DFEVar> ifmap, DFEVector<DFEVar> coeff) {
    this.ifmap <== ifmap;
    this.coeff <== coeff;
  }
  
  public DFEVector<DFEVar> getOfmap() {
    return this.ofmap;
  }
  
  private void initCounters() {
    CounterChain chain = getOwner().control.count.makeCounterChain();
    
    if (cp.seq == CompSeq.CHANNEL_MAJOR) {
      c = chain.addCounter(cp.C / cp.PC, 1).cast(dfeInt(32));
      f = chain.addCounter(cp.F / cp.PF, 1).cast(dfeInt(32));
      h = chain.addCounter(cp.H, 1).cast(dfeInt(32));
      w = chain.addCounter(cp.W / cp.PK, 1).cast(dfeInt(32));
    } else {
      throw new IllegalArgumentException(
          String.format(
              "Computation sequence %s has not been supported yet", cp.seq));
    }
  }
  
  private DFEVar getIfmapBufferAddr() {
    if (cp.seq == CompSeq.CHANNEL_MAJOR) {
      DFEVar addr = h * (cp.W / cp.PK) + w;
      return addr.cast(ibuf.getAddrT());
    } else {
      throw new IllegalArgumentException(
          String.format(
              "Computation sequence %s has not been supported yet", cp.seq));
    }
  }
  
  private DFEVar getIfmapBufferWriteEn() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return f.eq(0);
	    default:
	      throw new IllegalArgumentException(
	          String.format(
	              "Computation sequence %s has not been supported yet", cp.seq));
    }
  }
  
}
