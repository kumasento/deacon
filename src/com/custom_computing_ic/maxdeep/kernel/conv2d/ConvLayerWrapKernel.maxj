package com.custom_computing_ic.maxdeep.kernel.conv2d;

import com.custom_computing_ic.maxdeep.kernel.conv2d.ConvLayerParameters.Type;
import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelConfiguration;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.RoundingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix.SignMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

/**
 * Kernel for generating Conv2DKernel different parameters
 *
 * @author rz3515
 *
 */
public
class ConvLayerWrapKernel extends Kernel {
 public
  static final String IFMAP_NAME = "ifmap";
 public
  static final String COEFF_NAME = "coeff";
 public
  static final String DEPTHWISE_COEFF_NAME = "depthwise_coeff";
 public
  static final String POINTWISE_COEFF_NAME = "pointwise_coeff";
 public
  static final String OFMAP_NAME = "ofmap";

 private
  final ConvLayerParameters cp;

 public
  ConvLayerWrapKernel(KernelParameters params, ConvLayerParameters cp) {
    this(params, cp, 1);
  }

 public
  ConvLayerWrapKernel(KernelParameters params, ConvLayerParameters cp,
                      int numCoeffFifoSplits) {
    super(params);

    // KernelConfiguration config = getKernelConfig();
    // config.optimization.setFIFOImplementationBRAMThreshold(2048);
    // config.optimization
    // .setDSPMulAddChainBehavior(DSPMulAddChainBehaviour.IGNORE);

    this.cp = cp;

    // TODO: This type will return a signed integer when BW > 1
    DFEType scalarT = (cp.BW == 1) ? dfeUInt(1) : cp.getDFEType();

    /**
     * TODO: what is the proper way to initialise conv and cast the type?
     */
    if (cp.type == Type.STANDARD) {
      optimization.pushRoundingMode(RoundingMode.TRUNCATE);
      ConvLayerKernel conv = new ConvLayerKernel(getKernel(), cp, scalarT);
      optimization.popRoundingMode();

      DFEVector<DFEVar> ifmap =
          io.input(IFMAP_NAME, conv.getIfmapVecT(), conv.getIfmapEn());

      DFEVector<DFEVar> coeff;

      // We try to reduce the size of each FIFO
      if (numCoeffFifoSplits > 1) {
        int splitVecSize = conv.getCoeffVecSize() / numCoeffFifoSplits;
        DFEVectorType<DFEVar> CT =
            new DFEVectorType<DFEVar>(scalarT, splitVecSize);

        coeff = conv.getCoeffVecT().newInstance(this);
        for (int i = 0; i < numCoeffFifoSplits; i++) {
          DFEVector<DFEVar> tmp =
              io.input(COEFF_NAME + "_" + i, CT, conv.getCoeffEn());
          for (int j = 0; j < splitVecSize; j++) {
            coeff[i * splitVecSize + j].connect(tmp[i]);
          }
        }
      } else {
        // Just use the normal way
        coeff = io.input(COEFF_NAME, conv.getCoeffVecT(), conv.getCoeffEn());
      }

      conv.setInputs(ifmap, coeff);
      io.output(OFMAP_NAME, conv.getOfmapVecT(), conv.getOfmapEn())
          .connect(conv.getOfmap());

    } else if (cp.type == Type.DEPTHWISE_SEPARABLE) {
      DepthwiseSeparableConvLayerKernel conv =
          new DepthwiseSeparableConvLayerKernel(getKernel(), cp, scalarT);

      DFEVector<DFEVar> ifmap =
          io.input(IFMAP_NAME, conv.getIfmapVecT(), conv.getIfmapEn());
      DFEVector<DFEVar> depthwiseCoeff =
          io.input(DEPTHWISE_COEFF_NAME, conv.getDepthwiseCoeffVecT(),
                   conv.getDepthwiseCoeffEn());
      DFEVector<DFEVar> pointwiseCoeff =
          io.input(POINTWISE_COEFF_NAME, conv.getPointwiseCoeffVecT(),
                   conv.getPointwiseCoeffEn());

      conv.setInputs(ifmap, depthwiseCoeff, pointwiseCoeff);
      io.output(OFMAP_NAME, conv.getOfmapVecT(), conv.getOfmapEn())
          .connect(conv.getOfmap());

      if (cp.dbg) {
        debug.simPrintf("[ConvLayerWrapKernel] pointwise en = %d\n",
                        conv.getPointwiseCoeffEn());
      }

    } else if (cp.type == Type.DEPTHWISE_SEPARABLE_V2) {
      // create the kernel for depthwise separable convolution V2
      getManager().logMsg(
          "Initializing kernel for Depthwise Separable Convolution V2");

      DepthwiseSeparableConvLayerKernelV2 conv =
          new DepthwiseSeparableConvLayerKernelV2(getKernel(), cp, scalarT);
      conv.setIO(getKernel());
    } else {
      throw new IllegalArgumentException("type has no been supported");
    }
  }
}
