/**
 * 
 */
package com.custom_computing_ic.maxdeep.kernel.conv2d.lib;

import com.custom_computing_ic.maxdeep.kernel.conv2d.ConvLayerParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelBase;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelComponent;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

/**
 * @author Ruizhe Zhao
 * 
 */
public class ConvLayerLineBuffer extends KernelComponent {

  private final ConvLayerParameters   cp;

  private final DFEType               scalarT;
  private final DFEVectorType<DFEVar> inputVecT;
  private final DFEVectorType<DFEVar> outputVecT;

  private final DFEVector<DFEVar>     inputVec;
  private final DFEVector<DFEVar> outputVec;

  /**
   * constructor
   * 
   * @param owner
   * @param params
   * @param scalarT
   */
  public ConvLayerLineBuffer(KernelBase<?> owner, ConvLayerParameters params,
      DFEType scalarT) {
    super(owner);

    this.cp = params;

    this.scalarT = scalarT;
    
    /* input stream */
    this.inputVecT = new DFEVectorType<DFEVar>(scalarT, getInputVecSize());
    this.inputVec = inputVecT.newInstance(getOwner());
    
    /* output stream */
    this.outputVecT = new DFEVectorType<DFEVar>(scalarT, getOutputVecSize());
    this.outputVec = outputVecT.newInstance(getOwner());
    
    /* initialise line buffers */
    int numLineBuffers = getInputVecSize() / cp.PK;
    
    for (int i = 0; i < numLineBuffers; i ++) {
      
      /* initialise one line buffer */
      LineBufferKernel lbuf =
        new LineBufferKernel(getOwner(), cp.K, cp.W, cp.PK, scalarT);
      lbuf.setHeight(constant.var(cp.K).cast(lbuf.getIndexT()));
      lbuf.setWidth(constant.var(cp.W).cast(lbuf.getIndexT()));
      lbuf.setCapacity(constant.var(cp.H * cp.W).cast(lbuf.getIndexT()));
      
      /* create input vectors for line buffers */
      DFEVector<DFEVar> lbufInput = lbuf.getInputVecT().newInstance(getOwner());
      for (int j = 0; j < cp.PK; j ++)
        lbufInput[j] <== inputVec[i * cp.PK + j];
      lbuf.setInput(lbufInput);
      
      /* get results from line buffers */
      /* lbufOut has shape PK * K */
      DFEVector<DFEVar> lbufOutput = lbuf.getOutput();
      int numLbufOutputChunks = (cp.K + cp.PK - 1) / cp.PK;
      int lbufOutputChunkSize = lbufOutput.getSize();
      for (int j = 0; j < numLbufOutputChunks; j ++) {
        DFEVector<DFEVar> lbufOutputChunk =
          stream.offset(lbufOutput, - (numLbufOutputChunks - j - 1));
        
        /* outputVec: (PC, K, K + PK - 1) */
        for (int p = 0; p < cp.PK; p ++) {
	        for (int k = 0; k < cp.K; k ++) {
	          outputVec[i * (cp.K * (cp.K + cp.PK - 1)) +
	                    k * (cp.K + cp.PK - 1) +
	                    j * cp.PK +
	                    p] <== lbufOutputChunk[p * cp.K + k];
	        }
        }
        
      }
    }
    
    debug.simPrintf("inputVec = %KObj%\n", inputVec);
    debug.simPrintf("outputVec = %KObj%\n", outputVec);
  }

  public int getOutputVecSize() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return cp.PC * cp.K * (cp.K + cp.PK - 1);
      default:
        throw new IllegalArgumentException(String.format(
            "Computation sequence %s has not been supported yet", cp.seq));
    }
  }
  
  public DFEVectorType<DFEVar> getOutputVecT() {
    return outputVecT;
  }
  
  public DFEVector<DFEVar> getOutputVec() {
    return outputVec;
  }
  
  public int getInputVecSize() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return cp.PC * cp.PK;
      default:
        throw new IllegalArgumentException(String.format(
            "Computation sequence %s has not been supported yet", cp.seq));
    }
  }

  public DFEVectorType<DFEVar> getInputVecT() {
    return inputVecT;
  }
  
  public void setInput(DFEVector<DFEVar> inputVec) {
    this.inputVec <== inputVec;
  }
}
