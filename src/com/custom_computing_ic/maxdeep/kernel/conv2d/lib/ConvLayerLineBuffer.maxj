/**
 *
 */
package com.custom_computing_ic.maxdeep.kernel.conv2d.lib;

import com.custom_computing_ic.maxdeep.kernel.conv2d.ConvLayerParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelBase;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelComponent;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

/**
 * @author Ruizhe Zhao
 *
 */
public
class ConvLayerLineBuffer extends KernelComponent {
 private
  final ConvLayerParameters cp;

 private
  final DFEType scalarT;
 private
  final DFEVectorType<DFEVar> inputVecT;
 private
  final DFEVectorType<DFEVar> outputVecT;

 private
  final DFEVector<DFEVar> inputVec;
 private
  final DFEVector<DFEVar> outputVec;

 private
  final int lineBufferHeight;

  /**
   * constructor
   *
   * @param owner
   * @param params
   * @param scalarT
   */
 public ConvLayerLineBuffer(KernelBase<?> owner, ConvLayerParameters params, DFEType scalarT) {
    super(owner);

    this.cp = params;
    this.scalarT = scalarT;
    // height of the line buffer should be altered if the computation is
    // optimised by Winograd
    lineBufferHeight = (cp.useWinograd)
                           ? (ConvLayerParameters.WINOGRAD_TILE_SIZE + cp.K - 1)
                           : cp.K;
    owner.getManager().logMsg(
        String.format("Building line buffer for \"%s\" ...", params.name));
    owner.getManager().logMsg(String.format(
        "Line buffer shape %d x %d, produces %d number of %d x %d tiles " +
            "per cycle",
        lineBufferHeight, cp.W, cp.PK, lineBufferHeight, lineBufferHeight));
    owner.getManager().logMsg(String.format(
        "Line buffer input vector size: %d, output vector size: %d.",
        getInputVecSize(), getOutputVecSize()));

    /* input stream */
    this.inputVecT = new DFEVectorType<DFEVar>(scalarT, getInputVecSize());
    this.inputVec = inputVecT.newInstance(getOwner());

    /* output stream */
    this.outputVecT = new DFEVectorType<DFEVar>(scalarT, getOutputVecSize());
    this.outputVec = outputVecT.newInstance(getOwner());

    /* initialise line buffers */
    int numLineBuffers = getInputVecSize() / cp.PK;
    owner.getManager().logMsg(
        String.format("Number of separated line buffers: %d", numLineBuffers));

    for (int i = 0; i < numLineBuffers; i++) {
      /* initialise one line buffer */
      LineBufferKernel lbuf = new LineBufferKernel(getOwner(), lineBufferHeight,
                                                   cp.W, cp.PK, scalarT, false);
      // lbuf.setHeight(constant.var(lineBufferHeight).cast(lbuf.getIndexT()));
      lbuf.setWidth(constant.var(cp.W).cast(lbuf.getIndexT()));
      // lbuf.setCapacity(constant.var(cp.H * cp.W).cast(lbuf.getIndexT()));

      /* create input vectors for line buffers */
      DFEVector<DFEVar> lbufInput = lbuf.getInputVecT().newInstance(getOwner());
      for (int j = 0; j < cp.PK; j++)
        lbufInput[j].connect(inputVec[i * cp.PK + j]);
      lbuf.setInput(lbufInput);

      /* get results from line buffers */
      /* lbufOut has shape PK * K */
      DFEVector<DFEVar> lbufOutput = lbuf.getOutput();
      int numLbufOutputChunks = (lineBufferHeight + cp.PK - 1) / cp.PK;
      int lbufOutputChunkSize = lbufOutput.getSize();
      for (int j = 0; j < numLbufOutputChunks; j++) {
        DFEVector<DFEVar> lbufOutputChunk =
            stream.offset(lbufOutput, -(numLbufOutputChunks - j - 1));

        /* outputVec: (PC, K, K + PK - 1) */
        for (int p = 0; p < cp.PK; p++) {
          for (int k = 0; k < lineBufferHeight; k++) {
            int idx = i * (lineBufferHeight * (lineBufferHeight + cp.PK - 1)) +
                      k * (lineBufferHeight + cp.PK - 1) + j * cp.PK + p;

            outputVec[idx].connect(lbufOutputChunk[p * lineBufferHeight + k]);
          }
        }
      }
    }

    if (cp.dbg) {
      debug.simPrintf("Line buffer inputVec = %KObj%\n", inputVec);
      debug.simPrintf("Line buffer outputVec = %KObj%\n", outputVec);
    }
  }

 public
  int getOutputVecSize() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return cp.PC * lineBufferHeight * (lineBufferHeight + cp.PK - 1);
      case FILTER_MAJOR:
        return cp.PC * lineBufferHeight * (lineBufferHeight + cp.PK - 1);
      default:
        throw new IllegalArgumentException(String.format(
            "Computation sequence %s has not been supported yet", cp.seq));
    }
  }

 public
  DFEVectorType<DFEVar> getOutputVecT() { return outputVecT; }

 public
  DFEVector<DFEVar> getOutputVec() { return outputVec; }

 public
  int getInputVecSize() {
    switch (cp.seq) {
      case CHANNEL_MAJOR:
        return cp.PC * cp.PK;
      case FILTER_MAJOR:
        return cp.PC * cp.PK;
      default:
        throw new IllegalArgumentException(String.format(
            "Computation sequence %s has not been supported yet", cp.seq));
    }
  }

 public
  DFEVectorType<DFEVar> getInputVecT() { return inputVecT; }

 public
  void setInput(DFEVector<DFEVar> inputVec) { this.inputVec.connect(inputVec); }
}
