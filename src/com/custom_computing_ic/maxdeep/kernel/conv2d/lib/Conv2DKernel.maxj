/**
 * 
 */
package com.custom_computing_ic.maxdeep.kernel.conv2d.lib;

import java.util.ArrayList;
import java.util.List;

import com.custom_computing_ic.maxdeep.kernel.conv2d.ConvLayerParameters;
import com.custom_computing_ic.maxdeep.lib.DotProductKernel;
import com.custom_computing_ic.maxdeep.utils.AdderTree;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelBase;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelComponent;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

/**
 * This kernel implements the conv2d block.
 * 
 * INTERFACE:
 * *described in ruby*
 * <
 * <<X(1 ,1), X(1 ,2), ..., X(1 ,K*(K+PK))>,
 *  <X(2 ,1), X(2 ,2), ..., X(2 ,K*(K+PK))>,
 *  ...,
 *  <X(PC,1), X(PC,2), ..., X(PC,K*(K+PK))>>_PF,
 * <<W(1 ,1), W(1 ,2), ..., W(1 ,K*K)>,
 *  <W(2 ,1), W(2 ,2), ..., W(2 ,K*K)>,
 *  ...,
 *  <W(PC,1), W(PC,2), ..., W(PC,K*K)>>_PF
 * >
 * ~
 * <<Y(1 ,1), Y(1 ,2), ..., Y(1 ,PK)>,
 *  <Y(2 ,1), Y(2 ,2), ..., Y(2 ,PK)>,
 *  ...,
 *  <Y(PF,1), Y(PF,2), ..., Y(PF,PK)>> 
 * 
 * @author Ruizhe Zhao
 * 
 */
public class Conv2DKernel extends KernelComponent {

  private final DFEVectorType<DFEVar> ifmapVecT, coeffVecT, ofmapVecT;
  private final DFEVector<DFEVar>     ifmap, coeff, ofmap;
  private final ConvLayerParameters   convParams;
  private final DFEType               scalarT;

  /**
   * constructor
   * 
   * @param owner
   * @param convParams
   * @param scalarT
   */
  public Conv2DKernel(KernelBase<?> owner, ConvLayerParameters convParams,
      DFEType scalarT) {
    super(owner);

    this.convParams = convParams;

    int K = convParams.K;
    int PC = convParams.PC;
    int PF = convParams.PF;
    int PK = convParams.PK;
    
    int ifmapVecSize = (K * (K + PK - 1)) * PC;
    int coeffVecSize = K * K * PC * PF;
    int ofmapVecSize = PK * PF;

    this.scalarT = scalarT;

    this.ifmapVecT = new DFEVectorType<DFEVar>(scalarT, ifmapVecSize);
    this.coeffVecT = new DFEVectorType<DFEVar>(scalarT, coeffVecSize);
    this.ofmapVecT = new DFEVectorType<DFEVar>(scalarT, ofmapVecSize);

    this.ifmap = ifmapVecT.newInstance(owner);
    this.coeff = coeffVecT.newInstance(owner);
    this.ofmap = ofmapVecT.newInstance(owner);
    
    /**
     * computation
     */
    compute(ifmap, coeff, ofmap);
  }
  
  /**
   * core computation, based on dot-product.
   * @param ifmap
   * @param coeff
   * @param ofmap
   */
  public void compute(
      DFEVector<DFEVar> ifmap,
      DFEVector<DFEVar> coeff,
      DFEVector<DFEVar> ofmap)
  {
    int K = convParams.K;
    int PC = convParams.PC;
    int PF = convParams.PF;
    int PK = convParams.PK;
    
    for (int pf = 0; pf < PF; pf ++) {
      List<DFEVar> tmpResults = new ArrayList<DFEVar>(PK * PC);
      // TODO: initialise an ArrayList in this way might be silly
      for (int i = 0; i < PC * PK; i ++)
        tmpResults.add(null);
      
      for (int pc = 0; pc < PC; pc ++) {
        // create a new vector instance
        List<DFEVector<DFEVar>> ifmapChunks = getIfmapChunksAt(pc);
        
        // coefficient chunk
        DFEVector<DFEVar> coeffChunk = getCoeffChunkAt(pf, pc);
        
        for (int pk = 0; pk < PK; pk ++) {
          DFEVector<DFEVar> ifmapChunk = ifmapChunks.get(pk);
          
			    DotProductKernel dp =
			      new DotProductKernel(this.getOwner(), K * K, scalarT);
			    dp.setInputs(ifmapChunk, coeffChunk);
			    
			    tmpResults.set(pk * PC + pc, dp.getOutput());
        }
      }
      
      for (int pk = 0; pk < PK; pk ++)
        ofmap[pf * PK + pk] <==
          AdderTree.reduce(
              tmpResults.subList(pk * PC, (pk + 1) * PC));
    }
    
  }
  
  public DFEVectorType<DFEVar> getIfmapT() {
    return ifmapVecT;
  }
  
  public DFEVectorType<DFEVar> getCoeffT() {
    return coeffVecT;
  }
  
  public DFEVectorType<DFEVar> getOfmapT() {
    return ofmapVecT;
  }
  
  public void setInputs(DFEVector<DFEVar> ifmap, DFEVector<DFEVar> coeff) {
    this.ifmap <== ifmap;
    this.coeff <== coeff;
  }
  
  public DFEVector<DFEVar> getOfmap() { return ofmap; }
  
  /**
   * Get ifmap data chunk at (pc)
   * 
   * TODO: Each time you call this function, a new vector will be created,
   * might need caching in the future.
   * 
   * @param pc
   * @return
   */
  private List<DFEVector<DFEVar>> getIfmapChunksAt(int pc) {
    int K = convParams.K;
    int PC = convParams.PC;
    int PK = convParams.PK;
    
    if (pc >= PC)
      throw new IllegalArgumentException("pc should be smaller than PC");
    
    int ifmapPackedChunkSize = K * (K + PK - 1);
    
    DFEVectorType<DFEVar> ifmapPackedChunkT =
      new DFEVectorType<DFEVar>(scalarT, ifmapPackedChunkSize);
    
    DFEVector<DFEVar> ifmapPackedChunk = ifmapPackedChunkT.newInstance(getOwner());
    
    // create packed chunk
    for (int i = 0; i < ifmapPackedChunkSize; i ++)
      ifmapPackedChunk[i] <== ifmap[pc * ifmapPackedChunkSize + i];
    
    // unpack
    return unpackIfmapChunk(ifmapPackedChunk, convParams);
  }
  
  private DFEVector<DFEVar> getCoeffChunkAt(int pf, int pc) {
    int K = convParams.K;
    int PC = convParams.PC;
    
    int coeffChunkSize = K * K;
    
    DFEVectorType<DFEVar> coeffChunkT =
      new DFEVectorType<DFEVar>(scalarT, coeffChunkSize);
    DFEVector<DFEVar> coeffChunk = coeffChunkT.newInstance(getOwner());
    
    for (int i = 0; i < coeffChunkSize; i ++)
      coeffChunk[i] <== coeff[pf * PC * coeffChunkSize +
                              pc * coeffChunkSize +
                              i];
    
    return coeffChunk;
  }
  
  /**
   * Convert vector from (K, K + PK -1) to (PK, K, K)
   * 
   * @param src
   *          source vector
   * @param convParams
   * 
   * @author Ruizhe Zhao
   */
  private List<DFEVector<DFEVar>> unpackIfmapChunk(DFEVector<DFEVar> src,
      ConvLayerParameters convParams) {
    int K = convParams.K;
    int PK = convParams.PK;
    
    int ifmapChunkSize = K * K;
    DFEVectorType<DFEVar> ifmapChunkT =
      new DFEVectorType<DFEVar>(scalarT, ifmapChunkSize);
    List<DFEVector<DFEVar>> ifmapChunks =
      new ArrayList<DFEVector<DFEVar>>(PK);
    
    for (int p = 0; p < PK; p++) {
      ifmapChunks.add(p, ifmapChunkT.newInstance(getOwner()));
      
      for (int kx = 0; kx < K; kx++) {
        for (int ky = 0; ky < K; ky++) {
          int srcIdx = kx * (K + PK - 1) + (ky + p);
          int dstIdx = kx * K + ky;
          ifmapChunks.get(p)[dstIdx] <== src[srcIdx];
        }
      }
    }
    
    return ifmapChunks;
  }
}
