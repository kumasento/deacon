package com.custom_computing_ic.maxdeep.kernel.conv2d.lib;

import com.custom_computing_ic.maxdeep.kernel.conv2d.ConvLayerParameters;
import com.custom_computing_ic.maxdeep.kernel.conv2d.ConvLayerParameters.CompSeq;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelBase;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelComponent;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Buffer for output feature map stream.
 * 
 * HOW TO USE:
 * 
 * <pre>
 * {@link ConvLayerOfmapBuffer} obuf =
 *   new {@link ConvLayerOfmapBuffer}(getKernel(), cp, scalarT);
 * data <== obuf.port(addr, dataIn, writeEn);
 * </pre>
 * 
 * @author Ruizhe Zhao
 * @since 03/08/2017
 *
 */
public class ConvLayerOfmapBuffer extends KernelComponent {

  private final ConvLayerParameters       cp;

  private final DFEType                   scalarT;
  private final DFEVectorType<DFEVar>     portVecT;
  private final DFEType                   addrT;

  private final Memory<DFEVector<DFEVar>> mem;
  private final DFEVector<DFEVar>         port;
  private final DFEVar                    addr;
  private final DFEVector<DFEVar>         data;
  private final DFEVar                    writeEn;
  private final DFEVector<DFEVar>         result;
  
  private final int WRITE_LATENCY = 3;

  /**
   * 
   * @param owner
   * @param params
   * @param scalarT
   */
  public ConvLayerOfmapBuffer(KernelBase<?> owner, ConvLayerParameters params,
      DFEType scalarT) {
    super(owner);

    this.cp = params;
    this.scalarT = scalarT;

    int width = getWidth();
    int depth = getDepth();

    this.addrT = dfeUInt(MathUtils.bitsToAddress(depth));
    this.portVecT = new DFEVectorType<DFEVar>(scalarT, width);

    this.mem = owner.mem.alloc(portVecT, depth);
    this.addr = addrT.newInstance(owner);
    this.data = portVecT.newInstance(owner);
    this.writeEn = dfeBool().newInstance(owner);
    this.port = mem.read(addr); // mem.port(addr, data, writeEn, RamWriteMode.WRITE_FIRST);
    this.result = data + port;
    
    /* TODO: we assume the read result of an unwritten address is 0 */
    mem.write(
        stream.offset(addr, - WRITE_LATENCY),
        stream.offset(result, - WRITE_LATENCY),
        stream.offset(writeEn, - WRITE_LATENCY));
    
    debug.simPrintf("[ConvLayerOfmapBuffer] input = %KObj%\n", data);
    debug.simPrintf("[ConvLayerOfmapBuffer] read = %KObj%\n", port);
    debug.simPrintf("[ConvLayerOfmapBuffer] output = %KObj%\n", result);
    debug.simPrintf("[ConvLayerOfmapBuffer] writeEn = %KObj%\n", writeEn);
    debug.simPrintf("[ConvLayerOfmapBuffer] addr = %KObj%\n", addr);
  }
  
  public DFEType getAddrT() {
    return addrT;
  }

  public DFEVector<DFEVar> port(DFEVector<DFEVar> data, DFEVar addr, DFEVar writeEn) {
    this.data <== data;
    this.addr <== addr;
    this.writeEn <== writeEn;
    return this.result;
  }

  public DFEVectorType<DFEVar> getPortVecT() {
    return portVecT;
  }

  public int getWidth() {
    if (cp.seq == CompSeq.CHANNEL_MAJOR) {
      return cp.PK * cp.PF;
    } else {
      throw new IllegalArgumentException(String.format(
          "Computation sequence %s has not been supported yet", cp.seq));
    }
  }

  public int getDepth() {
    if (cp.seq == CompSeq.CHANNEL_MAJOR) {
      return cp.F * cp.OH * cp.OW / cp.PK;
    } else {
      throw new IllegalArgumentException(String.format(
          "Computation sequence %s has not been supported yet", cp.seq));
    }
  }
}
