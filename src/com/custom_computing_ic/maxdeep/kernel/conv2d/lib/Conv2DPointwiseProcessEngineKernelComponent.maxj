/**
 * 
 */
package com.custom_computing_ic.maxdeep.kernel.conv2d.lib;

import com.custom_computing_ic.maxdeep.kernel.conv2d.Conv2DParameter.Mode;
import com.maxeler.maxcompiler.v2.errors.MaxCompilerAPIError;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelBase;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelComponent;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

/**
 * This class implements the pointwise convolution process engine.
 * 
 * @author Ruizhe Zhao
 * @since 22/06/2017
 */
public final class Conv2DPointwiseProcessEngineKernelComponent extends
    KernelComponent {

  private final DFEType type;
  private final DFEType indexType;
  private final int     maxHeight;
  private final int     maxWidth;
  private final int     minHeight;
  private final int     minWidth;
  private final DFEVar  height;
  private final DFEVar  width;
  private final DFEVar  numChnl;
  private final DFEVar  inp;
  private final DFEVar  wgt;
  private final DFEVar  out;
  private final DFEVar  outVld;
  private DFEVar        cntChnl;
  private DFEVar        cntIdx;
  private final Mode    mode;
  
  private boolean hasHeight = false;
  private boolean hasWidth = false;
  private boolean hasNumChnl = false;
  private boolean hasInput = false;
  private boolean hasWeight = false;

  /**
   * Constructor.
   * 
   * @param owner
   */
  public Conv2DPointwiseProcessEngineKernelComponent(KernelBase<?> owner,
      DFEType type, int maxHeight, int maxWidth, int minHeight, int minWidth, Mode mode) {
    super(owner);

    if (maxHeight <= 0)
      throw new IllegalArgumentException("maxHeight should be larger than 0");
    if (maxWidth <= 0)
      throw new IllegalArgumentException("maxWidth should be larger than 0");
    if (minHeight <= 0)
      throw new IllegalArgumentException("minHeight should be larger than 0");
    if (minWidth <= 0)
      throw new IllegalArgumentException("minWidth should be larger than 0");
    if (minHeight > maxHeight)
      throw new IllegalArgumentException("minHeight should not be larger than maxHeight");
    if (minWidth > minHeight)
      throw new IllegalArgumentException("minWidth should not be larger than maxWidth");
    
    this.maxHeight = maxHeight;
    this.maxWidth = maxWidth;
    this.minHeight = minHeight;
    this.minWidth = minWidth;
    this.type = type;
    this.indexType = dfeInt(32);
    this.height = indexType.newInstance(owner);
    this.width = indexType.newInstance(owner);
    this.numChnl = indexType.newInstance(owner);
    this.mode = mode;

    inp = type.newInstance(owner);
    wgt = type.newInstance(owner);
    out = type.newInstance(owner);
    outVld = dfeBool().newInstance(owner);

    compute();
    
    // debug.simPrintf("%d %d %d %d\n", inp, wgt, out, outVld);
  }
  
  public void setInput(DFEVar inp) {this.hasInput = true; this.inp <== inp; }
  
  public void setWeight(DFEVar wgt) { this.hasWeight = true; this.wgt <== wgt; }
  
  public void setHeight(DFEVar height) { this.hasHeight = true; this.height <== height; }
  
  public void setWidth(DFEVar width) { this.hasWidth = true; this.width <== width; }
  
  public void setNumChnl(DFEVar numChnl) { this.hasNumChnl = true; this.numChnl <== numChnl; }

  public DFEVar getOutput() { return out; }
  
  public DFEVar getOutputValid() { return outVld; }

  private void compute() {
    if (mode == Mode.CHNL_MAJOR)
      throw new IllegalArgumentException(
          "The channel major mode of pointwise conv2d is not implemented yet.");
    else if (mode == Mode.FLTR_MAJOR)
      computeByFltrMajor();
    else
      throw new IllegalArgumentException("Cannot recognize mode.");
  }

  private void computeByFltrMajor() {
    CounterChain chain = getOwner().control.count.makeCounterChain();
    cntChnl = chain.addCounter(numChnl.cast(dfeUInt(32)), 1).cast(indexType);
    cntIdx = chain.addCounter((height * width).cast(dfeUInt(32)), 1).cast(indexType);

    DFEVar product = inp * wgt;
    DFEVar carriedSum = type.newInstance(getOwner());
    DFEVar sum = cntChnl === 0 ? 0 : carriedSum;
    DFEVar newSum = sum + product;
    
    DFEVar offset = -(height * width);
    int minOffset = -(maxHeight * maxWidth);
    int maxOffset = -(minHeight * minWidth);
    carriedSum <== stream.offset(newSum, offset, minOffset, maxOffset);
    
    out <== newSum;
    outVld <== cntChnl === numChnl - 1;
  }
  
  @Override
  protected void finalize() throws Throwable {
    super.finalize();

    if (!hasInput)
      throw new MaxCompilerAPIError("Input has not been connected.");
    if (!hasWeight)
      throw new MaxCompilerAPIError("Weight has not been connected.");
    if (!hasHeight)
      throw new MaxCompilerAPIError("Height has not been connected.");
    if (!hasWidth)
      throw new MaxCompilerAPIError("Witdh has not been connected.");
    if (!hasNumChnl)
      throw new MaxCompilerAPIError("NumChnl has not been connected.");
  }
}
