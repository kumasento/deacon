import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;

/**
 * The fully connected layer for the CNN network
 * @author Ruizhe Zhao <ruizhe.zhao15@imperial.ac.uk>
 */
class FCLayerKernel extends Kernel {

  private static final DFEType DATA_TYPE = dfeFloat(8, 24);

  public static final String FC_INP_NAME = "fc_inp";
  public static final String FC_OUT_NAME = "fc_out";
  public static final String FC_WGT_NAME = "fc_wgt";

  FCLayerKernel(KernelParameters params,
      int M, /* the height of the input matrix */
      int N  /* the width of the input matrix */
      )
  {
    super(params);

    OffsetExpr loopLength = stream.makeOffsetAutoLoop("fcLoopLength");
    DFEVar L = loopLength.getDFEVar(this, dfeUInt(8));

    CounterChain chain = control.count.makeCounterChain();
    DFEVar i = (M == 1) ? constant.var(0) : chain.addCounter(M, 1).cast(dfeInt(32));
    DFEVar j = (N == 1) ? constant.var(0) : chain.addCounter(N, 1).cast(dfeInt(32));
    DFEVar l = chain.addCounter(L, 1).cast(dfeUInt(8));

    // only read from the input stream while computing the first row
    DFEVar inpEnable = (i === 0) & (l === L - 1);
    DFEVar inp = io.input(FC_INP_NAME, DATA_TYPE, inpEnable);
    // weight input will always be enabled
    DFEVar wgt = io.input(FC_WGT_NAME, DATA_TYPE, l === L - 1);

    // input buffer
    Memory<DFEVar> inpBuf = mem.alloc(DATA_TYPE, N);
    DFEVar inpBufWriteAddr = j.cast(dfeUInt(MathUtils.bitsToAddress(N)));
    DFEVar inpVal = inpBuf.port(inpBufWriteAddr, inp, inpEnable, Mem.RamWriteMode.WRITE_FIRST);

    // computation 
    DFEVar out = DATA_TYPE.newInstance(this);
    DFEVar tmp = inpVal * wgt;
    DFEVar val = tmp + out;
    out <== (j === 0) ? tmp : stream.offset(val, -loopLength);

    DFEVar outEnable = (j === N-1) & (l === L-1);
    io.output(FC_OUT_NAME, out, DATA_TYPE, outEnable);
  }
}
