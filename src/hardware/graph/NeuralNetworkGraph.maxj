package maxdeep.graph;

import maxdeep.proto.MaxDeepProtos.*;
import java.util.*;

/**
 * A basic implementation of a neural network graph.
 *
 * This class stores an abstract of all layers within the neural network
 * and how they connect to each other. 
 * It is also a wrapper for different neural network configuration files,
 * currently it only supports protobuf (MaxDeepProtos).
 *
 * @author  Ruizhe Zhao <ruizhe.zhao15@imperial.ac.uk>
 * @version 1.0.0
 * @since   2016-12-17
 */
public class NeuralNetworkGraph {

  /** The pointer to the input layer of this graph */
  private LayerParameter inputLayer;
  /** A list stores all the layers of this neural network in sequence */
  private List<LayerParameter> layers;
  /** A map hashes blobs by their names */
  private Map<String, BlobShape> blobs;
  /** A map hashes the layer index by the top blobs of these layers  */
  private Map<String, Integer> blobTopOfLayer;
  /** A map hashes the layer index by the bottom blobs of these layers  */
  private Map<String, Integer> blobBtmOfLayer;
  /** Enum for types of layers */
  public enum LayerType {
    INPUT,
    CONV,
    POOL,
    RELU,
    FC
  };

  /**
   * A constructor that receives a param from the protobuf parser
   *
   * @param param The parameter object received from the protobuf parser
   */
  public NeuralNetworkGraph(NetParameter param) {
    // initialise objects
    this.layers         = param.getLayerList();
    this.blobs          = new HashMap<String, BlobShape>();
    this.blobTopOfLayer = new HashMap<String, Integer>();
    this.blobBtmOfLayer = new HashMap<String, Integer>();

    // walk through all the layers in this neural network
    int idx = 0;
    for (LayerParameter layer: layers) {
      String name = layer.getName();
      String top  = layer.getTop(0);    // assume only one top blob
      String type = layer.getType();

      System.out.println("Layer name:   " + name);
      System.out.println("Layer top:    " + layer.getTopList());
      System.out.println("Layer bottom: " + layer.getBottomList()); 
      System.out.println("Layer type:   " + type);
      System.out.println("");

      BlobShape btmShape = null;
      BlobShape.Builder topShapeBuilder = null;

      String btm;
      // store essential information for each layer
      if (getCanonicalLayerType(idx) == LayerType.INPUT) {
        this.inputLayer = layer;
        // store its top blob into the hash
        blobs.put(top, layer.getInputParam().getShape(0));
        blobTopOfLayer.put(top, idx);
      } else if (getCanonicalLayerType(idx) == LayerType.CONV) {
        btm = layer.getBottom(0);
        blobBtmOfLayer.put(btm, idx);
        blobTopOfLayer.put(top, idx);

        ConvolutionParameter convParam = layer.getConvolutionParam();
        int kernelSize                 = (int) convParam.getKernelSize(0);
        int stride                     = (int) convParam.getStride(0);
        int padding                    = (int) convParam.getPad(0);
        topShapeBuilder                = BlobShape.newBuilder();
        btmShape                       = blobs.get(btm);
        int topHeight                  = (int) (btmShape.getDim(2) + 2 * padding - kernelSize) / stride + 1;
        int topWidth                   = (int) (btmShape.getDim(3) + 2 * padding - kernelSize) / stride + 1;

        // create blob shape object for the top blob of the convolution layer.
        topShapeBuilder.addDim(btmShape.getDim(0));
        topShapeBuilder.addDim(convParam.getNumOutput());
        topShapeBuilder.addDim(topHeight);
        topShapeBuilder.addDim(topWidth);

        blobs.put(top, topShapeBuilder.build());
      } else if (getCanonicalLayerType(idx) == LayerType.FC) {
        // still suppose there is only one bottom
        btm = layer.getBottom(0);
        blobBtmOfLayer.put(btm, idx);
        blobTopOfLayer.put(top, idx);

        // calculate the blob shape for the top
        InnerProductParameter ipParam = layer.getInnerProductParam();
        int num_output                = ipParam.getNumOutput();
        topShapeBuilder               = BlobShape.newBuilder();
        btmShape                      = blobs.get(btm);
        
        // build the top blob shape
        topShapeBuilder.addDim(btmShape.getDim(0));
        topShapeBuilder.addDim(num_output);
        topShapeBuilder.addDim(1);
        topShapeBuilder.addDim(1);

        blobs.put(top, topShapeBuilder.build());
      } else if (getCanonicalLayerType(idx) == LayerType.POOL) {
        // still suppose there is only one bottom
        btm = layer.getBottom(0);
        blobBtmOfLayer.put(btm, idx);
        blobTopOfLayer.put(top, idx);

        // calculate the blob shape for the top
        PoolingParameter poolParam = layer.getPoolingParam();
        topShapeBuilder            = BlobShape.newBuilder();
        btmShape                   = blobs.get(btm);
        int pad                    = (int) getPadding(idx);
        int kernelSize             = (int) poolParam.getKernelSize();
        int stride                 = (int) poolParam.getStride();
        int topHeight              = (int) Math.ceil((double) (btmShape.getDim(2) + 2 * pad - kernelSize) / stride + 1);
        int topWidth               = (int) Math.ceil((double) (btmShape.getDim(3) + 2 * pad - kernelSize) / stride + 1);
        
        // build the top blob shape
        topShapeBuilder.addDim(btmShape.getDim(0));
        topShapeBuilder.addDim(btmShape.getDim(1));
        topShapeBuilder.addDim(topHeight);
        topShapeBuilder.addDim(topWidth);

        blobs.put(top, topShapeBuilder.build());

      } else if (getCanonicalLayerType(idx) == LayerType.RELU) {
        btm = layer.getBottom(0);
        blobBtmOfLayer.put(btm, idx);
        blobTopOfLayer.put(top, idx);

        topShapeBuilder = BlobShape.newBuilder();
        btmShape        = blobs.get(btm);
        // build the top blob shape
        topShapeBuilder.addDim(btmShape.getDim(0));
        topShapeBuilder.addDim(btmShape.getDim(1));
        topShapeBuilder.addDim(btmShape.getDim(2));
        topShapeBuilder.addDim(btmShape.getDim(3));

        blobs.put(top, topShapeBuilder.build());
      }

      idx += 1;
    }

    System.out.println("Blobs extracted from the prototxt");
    for (Map.Entry<String, BlobShape> entry: blobs.entrySet()) {
      BlobShape shape = entry.getValue();

      System.out.println("Name:  " + entry.getKey());
      System.out.println("Shape: ["
          + shape.getDim(0) + ", "
          + shape.getDim(1) + ", "
          + shape.getDim(2) + ", "
          + shape.getDim(3) + "]");
    }
  }
  // Boolean checkers {{{
  public Boolean isInputLayer(int idx) {
    return getLayerType(idx).equals("Input");
  }

  public Boolean isConvLayer(int idx) {
    return getLayerType(idx).equals("Convolution");
  }

  public Boolean isFCLayer(int idx) {
    return getLayerType(idx).equals("InnerProduct");
  }
  
  public Boolean isPoolingLayer(int idx) {
    return getLayerType(idx).equals("Pooling");
  }

  public Boolean isReLULayer(int idx) {
    return getLayerType(idx).equals("ReLU");
  }
  // }}}
  // Getters {{{
  /**
   * From the name in the prototxt file to Enum LayerType
   *
   * @param idx the index of a layer in layers list
   * @return The type of the layer
   */
  public LayerType getCanonicalLayerType(int idx) {
    if (layers[idx].getType().equals("Input"))
      return LayerType.INPUT;
    if (layers[idx].getType().equals("Convolution"))
      return LayerType.CONV;
    if (layers[idx].getType().equals("InnerProduct"))
      return LayerType.FC;
    if (layers[idx].getType().equals("Pooling"))
      return LayerType.POOL;
    if (layers[idx].getType().equals("ReLU"))
      return LayerType.RELU;
    return null;
  }

  public int getNumOfLayers() {
    return layers.size();
  }

  public String getLayerType(int idx) {
    return layers[idx].getType();
  }

  public String getLayerName(int idx) {
    return layers[idx].getName();
  }

  public String getLayerBtmName(int idx) {
    return layers[idx].getBottom(0);
  }

  public String getLayerTopName(int idx) {
    return layers[idx].getTop(0);
  }

  public int getBlobTopOfLayer(String blobName) {
    return blobTopOfLayer.get(blobName);
  }

  public int getBlobBtmOfLayer(String blobName) {
    return blobBtmOfLayer.get(blobName);
  }

  public int getLayerOutputSize(int idx) {
    String blobName = getLayerTopName(idx);
    BlobShape shape = blobs.get(blobName);
    if (isConvLayer(idx) || isPoolingLayer(idx)) {
      return (
          (int) shape.getDim(0) *
          (int) shape.getDim(1) *
          (int) shape.getDim(2) *
          (int) shape.getDim(3));
    }
    if (isFCLayer(idx)) {
      return (int) shape.getDim(0) * (int) shape.getDim(1);
    }
    throw new IllegalArgumentException("Layer's output size is not implemented");
  }

  public int getInputLayerSize() {
    InputParameter inputParam = inputLayer.getInputParam();
    BlobShape shape = inputParam.getShape(0);
    int inputLayerSize = 1;
    for (Long dim : shape.getDimList())
      inputLayerSize *= dim;
    return inputLayerSize;
  }

  public int getInputHeight(int idx) {
    LayerType type = getCanonicalLayerType(idx);
    if (type == LayerType.CONV ||
        type == LayerType.FC   ||
        type == LayerType.POOL ||
        type == LayerType.RELU)
      return (int) blobs.get(layers[idx].getBottom(0)).getDim(2);

    throw new IllegalArgumentException("Layer don't have input height");
  }

  public int getInputWidth(int idx) {
    LayerType type = getCanonicalLayerType(idx);
    if (type == LayerType.CONV ||
        type == LayerType.FC   ||
        type == LayerType.POOL ||
        type == LayerType.RELU)
      return (int) blobs.get(layers[idx].getBottom(0)).getDim(3);
    
    throw new IllegalArgumentException("Layer don't have input width");
  }

  public int getInputChannel(int idx) {
    LayerType type = getCanonicalLayerType(idx);
    if (type == LayerType.CONV ||
        type == LayerType.FC   ||
        type == LayerType.POOL ||
        type == LayerType.RELU)
      return (int) blobs.get(layers[idx].getBottom(0)).getDim(1);

    throw new IllegalArgumentException("Layer don't have input channel");
  }

  public int getOutputChannel(int idx) {
    LayerType type = getCanonicalLayerType(idx);
    if (type == LayerType.CONV ||
        type == LayerType.FC   ||
        type == LayerType.POOL ||
        type == LayerType.RELU)
      return (int) blobs.get(layers[idx].getTop(0)).getDim(1);

    throw new IllegalArgumentException("Layer don't have output channel");
  }

  public int getKernelSize(int idx) {
    LayerType type = getCanonicalLayerType(idx);
    if (type == LayerType.CONV)
      return layers[idx].getConvolutionParam().getKernelSize(0);
    if (type == LayerType.POOL)
      return layers[idx].getPoolingParam().getKernelSize();
    
    throw new IllegalArgumentException("Layer don't have kernel size");
  }

  public int getStride(int idx) {
    LayerType type = getCanonicalLayerType(idx);
    if (type == LayerType.CONV)
      return layers[idx].getConvolutionParam().getStride(0);
    if (type == LayerType.POOL)
      return layers[idx].getPoolingParam().getStride();

    throw new IllegalArgumentException("Layer don't have kernel size");
  }
  
  public int getPadding(int idx) {
    LayerType type = getCanonicalLayerType(idx);
    if (type == LayerType.CONV)
      return layers[idx].getConvolutionParam().getPad(0);
    if (type == LayerType.POOL) {
      PoolingParameter param = layers[idx].getPoolingParam();
      return (param.getPadCount() == 0) ? 0 : param.getPad(0);
    }
    throw new IllegalArgumentException("Layer don't have padding");
  }
  // }}}
}
