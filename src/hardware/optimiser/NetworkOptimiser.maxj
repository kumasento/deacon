package maxdeep.optimiser;

// import com.maxeler.maxcompiler.v2.build.EngineParameters;
import com.maxeler.maxcompiler.v2.managers.custom.DFELink;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.KernelBlock;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;

import maxdeep.kernels.*;
import maxdeep.managers.NetworkManager;
import maxdeep.graph.NeuralNetworkGraph;

import java.util.*;
import java.util.logging.*;

public class NetworkOptimiser {

  private final static Logger LOGGER =
    Logger.getLogger(NetworkOptimiser.class.getName());

  private static final CPUTypes DEFAULT_CPU_INP_TYPE = CPUTypes.FLOAT;
  private static final CPUTypes DEFAULT_CPU_OUT_TYPE = CPUTypes.FLOAT;
  private static final String DEFAULT_CPU_INP_NAME = "cpu_inp";
  private static final String DEFAULT_CPU_OUT_NAME = "cpu_out";

  private Map<String, KernelBlock> kernelBlocks;

  public NetworkOptimiser() {
    LOGGER.setLevel(Level.INFO);
  }

  public void optimise(NetworkManager manager, NeuralNetworkGraph graph) {
    kernelBlocks = new HashMap<String, KernelBlock>();
    EngineInterface ei = new EngineInterface();

    // Setup input stream from CPU {{{
    
    int inputStreamSize = graph.getInputLayerSize();
    LOGGER.info("Input stream size: " + inputStreamSize);

    DFELink CPUInp = manager.addStreamFromCPU(DEFAULT_CPU_INP_NAME);
    ei.setStream(DEFAULT_CPU_INP_NAME, DEFAULT_CPU_INP_TYPE,
        inputStreamSize * DEFAULT_CPU_INP_TYPE.sizeInBytes());
    
    // }}}
    // Create kernels {{{

    int idx;
    int numOfLayers = graph.getNumOfLayers();
    for (idx = 1; idx < numOfLayers; idx ++) {
      // skip the first index, which is the input layer
      String name = null;
      KernelBlock knl = null;

      // Conv Layer {{{
      if (graph.isConvLayer(idx)) {
        int H = graph.getInputHeight(idx);
        int W = graph.getInputWidth(idx);
        int C = graph.getInputChannel(idx);
        int F = graph.getOutputChannel(idx);
        int K = graph.getKernelSize(idx);
        int P = graph.getPadding(idx);
        int S = graph.getStride(idx);

        int P_F = 4;

        name = graph.getLayerName(idx);
        LOGGER.info("Creating CONV layer: " + name);
        LOGGER.info("H = " + Integer.toString(H));
        LOGGER.info("W = " + Integer.toString(W));
        LOGGER.info("C = " + Integer.toString(C));
        LOGGER.info("F = " + Integer.toString(F));
        LOGGER.info("K = " + Integer.toString(K));
        LOGGER.info("P = " + Integer.toString(P));
        LOGGER.info("S = " + Integer.toString(S));
        LOGGER.info("P_F = " + Integer.toString(P_F));

        if (F < P_F || F % P_F != 0)
          throw new IllegalArgumentException("S * P_F should be divided by W");

        knl = manager.addKernel(
            new ConvLayerKernel(
              manager.makeKernelParameters(graph.getLayerName(idx)),
              H, W, F, C, K, P, S, P_F));

        String acc_knl_name = name + "_acc_knl";
        KernelBlock acc_knl = manager.addKernel(
            new ConvAccumKernel(
              manager.makeKernelParameters(acc_knl_name),
              H, W, F, C, K, P, S, P_F));

        // add a stream for the weight input
        String wgtName = name + "_wgt";
        DFELink wgtFromCPU = manager.addStreamFromCPU(wgtName);
        knl.getInput("wgt") <== wgtFromCPU;
        ei.setStream(wgtName, CPUTypes.FLOAT,
            K * K * C * F * CPUTypes.FLOAT.sizeInBytes());

        // add a stream for the bias input
        String biasName = name + "_bias";
        DFELink biasFromCPU = manager.addStreamFromCPU(biasName);
        acc_knl.getInput(ConvAccumKernel.BIAS_NAME) <== biasFromCPU;
        ei.setStream(biasName, CPUTypes.FLOAT,
            F * CPUTypes.FLOAT.sizeInBytes());

        int ticks = H * W * F * C / P_F;

        // setup conv kernel
        for (int f = 0; f < P_F; f ++) {
          String conv_knl_name = name + "_conv_knl_" + Integer.toString(f);

          KernelBlock conv_knl = manager.addKernel(
              new ConvolveKernel(
                manager.makeKernelParameters(conv_knl_name), K));

          String suffix = "_" + Integer.toString(f);

          conv_knl.getInput(ConvolveKernel.INP_NAME)
            <== knl.getOutput(ConvLayerKernel.CONV_KNL_INP_NAME + suffix);
          conv_knl.getInput(ConvolveKernel.WGT_NAME)
            <== knl.getOutput(ConvLayerKernel.CONV_KNL_WGT_NAME + suffix);
          acc_knl.getInput(ConvAccumKernel.CONV_KNL_OUT_NAME + suffix)
            <== conv_knl.getOutput(ConvolveKernel.OUT_NAME);

          ei.setTicks(conv_knl_name, ticks);
        }

        int oH = (H + 2 * P - K) / S + 1;
        int oW = (W + 2 * P - K) / S + 1;

        String conv_out_knl_name = name + "_out";
        KernelBlock conv_out_knl = manager.addKernel(
            new ConvOutputKernel(
              manager.makeKernelParameters(conv_out_knl_name),
              oH * oW, F, P_F));
        ei.setTicks(conv_out_knl_name, oH * oW * F);
        conv_out_knl.getInput(ConvOutputKernel.INP_NAME)
          <== acc_knl.getOutput(ConvAccumKernel.OUT_NAME);

        // setup ticks
        ei.setTicks(name,         ticks);
        ei.setTicks(acc_knl_name, ticks);
        LOGGER.info("ticks = " + Integer.toString(H * W * C));
        LOGGER.info("size of weights = " +
            Integer.toString(K * K * C * F * CPUTypes.FLOAT.sizeInBytes()));

        kernelBlocks.put(acc_knl_name, acc_knl);
        kernelBlocks.put(conv_out_knl_name, conv_out_knl);
      } 
      // }}}
      // FC Layer {{{
      else if (graph.isFCLayer(idx)) {
        int H = graph.getInputHeight(idx);
        int W = graph.getInputWidth(idx);
        int C = graph.getInputChannel(idx);
        int numOutput = graph.getOutputChannel(idx);

        int N = H * W * C;
        int M = numOutput;
        int P_V = 4;

        name = graph.getLayerName(idx);

        LOGGER.info("Creating FC layer: " + name);
        LOGGER.info("H = " + Integer.toString(H));
        LOGGER.info("W = " + Integer.toString(W));
        LOGGER.info("C = " + Integer.toString(C));
        LOGGER.info("M = " + Integer.toString(M));
        LOGGER.info("P_V = " + Integer.toString(P_V));
        LOGGER.info("numOutput = " + Integer.toString(numOutput));

        // inp kernel
        String inp_name = name + "_inp";
        KernelBlock inp_knl = manager.addKernel(
            new FCLayerInpKernel(
              manager.makeKernelParameters(inp_name), M, N, P_V));
        kernelBlocks.put(inp_name, inp_knl);
        ei.setTicks(inp_name, M * N / P_V);

        // out kernel
        String out_name = name + "_out";
        KernelBlock out_knl = manager.addKernel(
            new FCLayerOutKernel(
              manager.makeKernelParameters(out_name), P_V));
        kernelBlocks.put(out_name, out_knl);
        ei.setTicks(out_name, M / P_V);

        // weight
        String wgtName = name + "_wgt";
        DFELink wgtFromCPU = manager.addStreamFromCPU(wgtName);
        inp_knl.getInput(FCLayerInpKernel.WGT_NAME) <== wgtFromCPU;
        ei.setStream(wgtName, CPUTypes.FLOAT,
            M * N * CPUTypes.FLOAT.sizeInBytes());

        // bias
        String biasName = name + "_bias";
        DFELink biasFromCPU = manager.addStreamFromCPU(biasName);
        inp_knl.getInput(FCLayerInpKernel.BIAS_NAME) <== biasFromCPU;
        ei.setStream(biasName, CPUTypes.FLOAT,
            M * CPUTypes.FLOAT.sizeInBytes());
        
        // dot product kernels
        for (int p = 0; p < P_V; p ++) {
          String dot_name = name + "_dot_" + Integer.toString(p);
          String suffix = "_" + Integer.toString(p);

          KernelBlock dot_knl = manager.addKernel(
              new FCLayerDotProductKernel(
                manager.makeKernelParameters(dot_name), M / P_V, N));
          kernelBlocks.put(dot_name, dot_knl);

          // loop offset
          InterfaceParam L = ei.getAutoLoopOffset(dot_name, "fcLoopLength");
          ei.ignoreAutoLoopOffset(dot_name, "fcLoopLength");
          ei.setTicks(dot_name, M / P_V * N * L);

          dot_knl.getInput(FCLayerDotProductKernel.INP_NAME)
            <== inp_knl.getOutput(FCLayerInpKernel.INP_NAME + suffix);
          dot_knl.getInput(FCLayerDotProductKernel.WGT_NAME)
            <== inp_knl.getOutput(FCLayerInpKernel.WGT_NAME + suffix);
          dot_knl.getInput(FCLayerDotProductKernel.BIAS_NAME)
            <== inp_knl.getOutput(FCLayerInpKernel.BIAS_NAME + suffix);
          out_knl.getInput(FCLayerOutKernel.INP_NAME + suffix)
            <== dot_knl.getOutput(FCLayerDotProductKernel.OUT_NAME);
        }


        /* old version
        // create kernel block
        knl = manager.addKernel(
            new FCLayerKernel(
              manager.makeKernelParameters(name), M, N, P_V));

        // weight
        String wgtName = name + "_wgt";
        DFELink wgtFromCPU = manager.addStreamFromCPU(wgtName);
        knl.getInput(FCLayerKernel.WGT_NAME) <== wgtFromCPU;
        ei.setStream(wgtName, CPUTypes.FLOAT,
            M * N * CPUTypes.FLOAT.sizeInBytes());

        // bias
        String biasName = name + "_bias";
        DFELink biasFromCPU = manager.addStreamFromCPU(biasName);
        knl.getInput(FCLayerKernel.BIAS_NAME) <== biasFromCPU;
        ei.setStream(biasName, CPUTypes.FLOAT,
            M * CPUTypes.FLOAT.sizeInBytes());

        // loop offset
        InterfaceParam L = ei.getAutoLoopOffset(name, "fcLoopLength");
        ei.ignoreAutoLoopOffset(name, "fcLoopLength");

        // ticks
        ei.setTicks(name, L * N * M / P_V);
        */ 
      }
      // }}}
      // Pooling Layer {{{
      else if (graph.isPoolingLayer(idx)) {
        int H = graph.getInputHeight(idx);
        int W = graph.getInputWidth(idx);
        int C = graph.getInputChannel(idx);
        int S = graph.getStride(idx);
        int P = graph.getPadding(idx);
        int K = graph.getKernelSize(idx);

        name = graph.getLayerName(idx);

        LOGGER.info("Creating Pooling layer: " + name);
        LOGGER.info("H = " + Integer.toString(H));
        LOGGER.info("W = " + Integer.toString(W));
        LOGGER.info("C = " + Integer.toString(C));
        LOGGER.info("K = " + Integer.toString(K));
        LOGGER.info("S = " + Integer.toString(S));

        knl = manager.addKernel(
            new PoolingLayerKernel(
              manager.makeKernelParameters(name),
              H, W, C, K, P, S));

        ei.setTicks(name, C * H * W);
      }
      // }}}
      // ReLU Layer {{{
      else if (graph.isReLULayer(idx)) {
        int H = graph.getInputHeight(idx);
        int W = graph.getInputWidth(idx);
        int C = graph.getInputChannel(idx);

        name = graph.getLayerName(idx);
        LOGGER.info("Creating ReLU layer: " + name);
        knl = manager.addKernel(
            new ReLULayerKernel(manager.makeKernelParameters(name)));
        ei.setTicks(name, C * H * W);
      }
      // }}}
      else {
        throw new UnsupportedOperationException("Layer type not supported");
      }

      kernelBlocks.put(name, knl);
    }

    // }}}
    // Connect KernelBlocks {{{

    // connect kernels to each other by using top and bottom
    // the connection is established through blob
    for (idx = 1; idx < numOfLayers; idx ++) {
      // connect its top to the bottom blobs it belongs to
      String btm = graph.getLayerBtmName(idx);
      String top = graph.getLayerTopName(idx);
      KernelBlock btmInpKnl, btmOutKnl;

      if (graph.isFCLayer(idx))
        btmInpKnl = kernelBlocks.get(graph.getLayerName(idx) + "_inp");
      else
        btmInpKnl = kernelBlocks.get(graph.getLayerName(idx));

      if (graph.isConvLayer(idx) || graph.isFCLayer(idx))
        btmOutKnl = kernelBlocks.get(graph.getLayerName(idx) + "_out");
      else
        btmOutKnl = kernelBlocks.get(graph.getLayerName(idx));

      int topIdx = graph.getBlobTopOfLayer(btm);

      LOGGER.info("[" + btm + "] -> [" + top + "]");
      
      if (graph.isInputLayer(topIdx)) {
        btmInpKnl.getInput("inp") <== CPUInp;
      }
      else {
        KernelBlock topKnl = kernelBlocks.get(graph.getLayerName(topIdx)); 
        btmInpKnl.getInput("inp") <== topKnl.getOutput("opt");
      }

      if (idx == numOfLayers - 1) {
        DFELink CPUOut = manager.addStreamToCPU(DEFAULT_CPU_OUT_NAME);

        CPUOut <== btmOutKnl.getOutput("opt");
        ei.setStream(DEFAULT_CPU_OUT_NAME, DEFAULT_CPU_OUT_TYPE,
          graph.getLayerOutputSize(idx) * DEFAULT_CPU_OUT_TYPE.sizeInBytes());
        LOGGER.info("output size: " + Integer.toString(
              graph.getLayerOutputSize(idx)));
      }
    }
    // }}}
    
    manager.createSLiCinterface(ei);
  }
}
