package maxdeep.kernels;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

/**
 * The computation kernel that focuses on computing convolution.
 *
 * This kernel has no buffer, no complicated loop control. It just takes
 * input and weight of size k*k from the ConvLayerKernel and send back a 
 * convolution result.
 *
 * @author Ruizhe Zhao <ruizhe.zhao15@imperial.ac.uk>
 * @since  2017-01-03
 */
public class ConvolveKernel extends Kernel {

  public static final String INP_NAME = "inp";
  public static final String WGT_NAME = "wgt";
  public static final String OUT_NAME = "opt";

  public ConvolveKernel(KernelParameters params,
    int K, /* kernel size */
    DFEType DATA_TYPE
  ) {
    super(params);

    // vector type for inp and wgt
    DFEVectorType<DFEVar> VEC_TYPE =
      new DFEVectorType<DFEVar>(DATA_TYPE, K * K);
    
    // input stream
    DFEVector<DFEVar> inp = io.input(INP_NAME, VEC_TYPE);

    // weight stream
    DFEVector<DFEVar> wgt = io.input(WGT_NAME, VEC_TYPE);
    // inp.simWatch("inp");
    // wgt.simWatch("wgt");

    // window to store temporary result
    DFEVar window [] = new DFEVar [ K * K ];

    // window index
    for (int x = 0; x < K; x ++)
      for (int y = 0; y < K; y ++) 
        window[ x * K + y ] = wgt[ x * K + y ] * inp[ x * K + y ] ;

    // sum up
    DFEVar sum = constant.var(0);
    for (DFEVar tmp: window)
      sum = sum + tmp;

    // sum.simWatch("sum");
    io.output(OUT_NAME, sum, DATA_TYPE);
  }
}
