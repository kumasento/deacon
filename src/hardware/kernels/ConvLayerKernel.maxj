package maxdeep.kernels;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * The convolution layer for the CNN network
 * @author Ruizhe Zhao <ruizhe.zhao15@imperial.ac.uk>
 */
public class ConvLayerKernel extends Kernel {

  public static final String INP_NAME  = "inp";
  public static final String WGT_NAME  = "wgts";
  public static final String OUT_NAME  = "opt";
  public static final String BIAS_NAME = "bias";

  public static final String CONV_KNL_WGT_NAME = "conv_knl_wgt";
  public static final String CONV_KNL_INP_NAME = "conv_knl_inp";
  public static final String CONV_KNL_OUT_NAME = "conv_knl_opt";

  private static final DFEType DATA_TYPE = dfeFloat(8, 24);

  public ConvLayerKernel(KernelParameters params,
      int H,  /* height of the input feature map */
      int W,  /* width of the input feature map */
      int F,  /* number of output filters */
      int C,  /* number of input feature map channels */
      int K,  /* kernel size */
      int P,  /* padding size */
      int S,  /* stride size */
      int P_F /* parallel in filter */
  ) {
    super(params);

    // Constants {{{

    // input buffer stores a feature map for a single channel
    int KERNEL_UPPER         =   K / 2;
    int KERNEL_LOWER         = - K / 2;
    int INPUT_BUF_SIZE       = H * W;
    int WEIGHT_BUF_SIZE      = C * F * K * K;
    int INPUT_BUF_ADDR_BITS  = MathUtils.bitsToAddress(INPUT_BUF_SIZE);
    int WEIGHT_BUF_ADDR_BITS = MathUtils.bitsToAddress(WEIGHT_BUF_SIZE);

    if (K % 2 == 0)
      KERNEL_UPPER --;

    // }}}
    // Counter {{{
    
    CounterChain chain = control.count.makeCounterChain();
    DFEVar c  = (C == 1)
      ? constant.var(0)
      : chain.addCounter(C, 1).cast(dfeInt(32));
    DFEVar f  = (F == 1)
      ? constant.var(0)
      : chain.addCounter(F, P_F).cast(dfeInt(32));
    DFEVar x  = chain.addCounter(H, S).cast(dfeInt(32));
    DFEVar sx = (S == 1)
      ? constant.var(0) : chain.addCounter(S, 1).cast(dfeInt(32));
    DFEVar y  = chain.addCounter(W, S).cast(dfeInt(32));
    DFEVar sy = (S == 1)
      ? constant.var(0) : chain.addCounter(S, 1).cast(dfeInt(32));
    DFEVar rx = x + sx;
    DFEVar ry = y + sy;

    c.simWatch("c");
    f.simWatch("f");
    rx.simWatch("rx");
    ry.simWatch("ry");

    DFEVectorType<DFEVar> VEC_TYPE = 
      new DFEVectorType<DFEVar>(DATA_TYPE, K * K);

    // }}}
    // Input Stream {{{
    
    DFEVar inpEnable = (f === 0).cast(dfeBool());
    DFEVar inp = io.input(INP_NAME, DATA_TYPE, inpEnable);

    // }}}
    // Weight Buffer {{{
   
    Memory<DFEVar> wgtMem = mem.alloc(DATA_TYPE, K * K * C * F);
    wgtMem.mapToCPU(WGT_NAME);

    // }}}
    // Input Buffer {{{

    Memory<DFEVar> inputBuf = mem.alloc(DATA_TYPE, INPUT_BUF_SIZE);

    DFEVar writeInpBufAddr = (rx * W + ry);
    writeInpBufAddr = writeInpBufAddr.cast(dfeUInt(INPUT_BUF_ADDR_BITS));
    inputBuf.write(writeInpBufAddr, inp, inpEnable);

    // }}}
    // Generate inp and wgt vectors {{{

    // Input vector {{{
    DFEVector<DFEVar> inpVec = VEC_TYPE.newInstance(this);
    int i = 0;
    for (int dx = KERNEL_LOWER; dx <= KERNEL_UPPER; dx ++) {
      for (int dy = KERNEL_LOWER; dy <= KERNEL_UPPER; dy ++) {
        // conditions
        DFEVar aboveUpper = rx + dx >= H | ry + dy >= W;
        DFEVar belowLower = rx + dx <  0 | ry + dy <  0;
        DFEVar outOfBound = ( aboveUpper | belowLower );
        DFEVar readEnable = inpEnable;

        // address
        // transform 2d coordinates to 1d vector indices
        DFEVar readInpBufAddr  = (rx + dx) * H + (ry + dy);
        readInpBufAddr = readInpBufAddr.cast(dfeUInt(INPUT_BUF_ADDR_BITS));

        // read from stream only when f == 0
        DFEVar curr = (outOfBound)
          ? constant.var(0)
          : ((readEnable) 
              ? stream.offset(inp, dx * W + dy)
              : inputBuf.read(readInpBufAddr));

        // assign
        inpVec[i ++] <== curr;
      }
    }
    // }}}
    // Weight {{{
    for (int idx = 0; idx < P_F; idx ++) {
      DFEVector<DFEVar> wgtVec = VEC_TYPE.newInstance(this);

      for (int k = 0; k < K * K; k ++) {
        DFEVar wgtReadAddr = (
            c * (F * K * K) +
            (f + idx) * (K * K) +
            k).cast(dfeUInt(WEIGHT_BUF_ADDR_BITS));
        wgtVec[k] <== wgtMem.read(wgtReadAddr);
      }

      String suffix = "_" + Integer.toString(idx);
      io.output(CONV_KNL_INP_NAME + suffix, inpVec, VEC_TYPE);
      io.output(CONV_KNL_WGT_NAME + suffix, wgtVec, VEC_TYPE);
    }
    // }}}

    // }}}
  }
}
