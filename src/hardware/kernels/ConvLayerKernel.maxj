package maxdeep.kernels;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * The convolution layer for the CNN network
 * @author Ruizhe Zhao <ruizhe.zhao15@imperial.ac.uk>
 */
public class ConvLayerKernel extends Kernel {

  public static final String CONV_INP_NAME = "inp";
  public static final String CONV_WGT_NAME = "wgt";
  public static final String CONV_OUT_NAME = "opt";
  public static final String BIAS_NAME = "bias";

  private static final DFEType DATA_TYPE = dfeFloat(8, 24);

  public ConvLayerKernel(KernelParameters params,
      int H, /* height of the input feature map */
      int W, /* width of the input feature map */
      int F, /* number of output filters */
      int C, /* number of input feature map channels */
      int K, /* kernel size */
      int P, /* padding size */
      int S  /* stride size */
  ) {
    super(params);

    // Constants {{{
    // input buffer stores a feature map for a single channel
    int KERNEL_UPPER         =   K / 2;
    int KERNEL_LOWER         = - K / 2;
    int INPUT_BUF_SIZE       = H * W;
    int OUTPUT_BUF_SIZE      = H * W * F;
    int WEIGHT_BUF_SIZE      = C * F;
    int INPUT_BUF_ADDR_BITS  = MathUtils.bitsToAddress(INPUT_BUF_SIZE);
    int OUTPUT_BUF_ADDR_BITS = MathUtils.bitsToAddress(OUTPUT_BUF_SIZE);
    int WEIGHT_BUF_ADDR_BITS = MathUtils.bitsToAddress(WEIGHT_BUF_SIZE);
    int OUTPUT_SX            = (- KERNEL_LOWER - P) % S;
    int OUTPUT_SY            = (- KERNEL_LOWER - P) % S;
    // }}}
    // Counter {{{
    
    CounterChain chain = control.count.makeCounterChain();
    DFEVar c  = (C == 1)
      ? constant.var(0)
      : chain.addCounter(C, 1).cast(dfeInt(32));
    DFEVar f  = chain.addCounter(F, 1).cast(dfeInt(32));
    DFEVar x  = chain.addCounter(H, S).cast(dfeInt(32));
    DFEVar sx = (S == 1)
      ? constant.var(0) : chain.addCounter(S, 1).cast(dfeInt(32));
    DFEVar y  = chain.addCounter(W, S).cast(dfeInt(32));
    DFEVar sy = (S == 1)
      ? constant.var(0) : chain.addCounter(S, 1).cast(dfeInt(32));

    DFEVar rx = x + sx;
    DFEVar ry = y + sy;

    // }}}
    // Input Stream {{{
    
    DFEVar inpEnable = (f === 0).cast(dfeBool());
    DFEVar inp = io.input(CONV_INP_NAME, DATA_TYPE, inpEnable);

    // }}}
    // Weight Stream {{{
    // only read weight vector at the begining of the first channel's
    // computation
   
    DFEVar wgtEnable = (rx === 0 & ry === 0);
    DFEVectorType<DFEVar> WEIGHT_TYPE = 
      new DFEVectorType<DFEVar>(DATA_TYPE, K * K);
    DFEVector<DFEVar> wgtInpVec = io.input(CONV_WGT_NAME, WEIGHT_TYPE,
        wgtEnable); 

    // }}}
    // Bias Stream {{{
    
    // bias will be loaded when computing the first channel's first element.
    // each filter will have a new bias loaded while computing the first channel
    DFEVar biasEnable = (c === 0 & rx === 0 & ry === 0);

    // the bias term
    DFEVar bias = io.input(BIAS_NAME, DATA_TYPE, biasEnable);
    
    // }}}
    // Input Buffer {{{
    Memory<DFEVar> inputBuf = mem.alloc(DATA_TYPE, INPUT_BUF_SIZE);

    DFEVar writeInpBufAddr = (rx * H + ry);
    writeInpBufAddr = writeInpBufAddr.cast(dfeUInt(INPUT_BUF_ADDR_BITS));
    inputBuf.write(writeInpBufAddr, inp, inpEnable);

    // }}}
    // Weight buffer {{{

    Memory<DFEVector<DFEVar>> wgtBuf = mem.alloc(WEIGHT_TYPE, WEIGHT_BUF_SIZE);
    DFEVar wgtBufAddr = (c * F + f).cast(dfeUInt(WEIGHT_BUF_ADDR_BITS));

    wgtBuf.write(wgtBufAddr, wgtInpVec, wgtEnable);

    // }}}
    // Output Buffer {{{

    Memory<DFEVar> outputBuf = mem.alloc(DATA_TYPE, OUTPUT_BUF_SIZE);

    DFEVar writeOutBufAddr = (f * H * W + rx * H + ry).cast(dfeUInt(OUTPUT_BUF_ADDR_BITS));

    // }}}
    // Create Convolution Window {{{

    // a window of kernel
    DFEVar window [] = new DFEVar [K * K]; 

    DFEVector<DFEVar> wgtVec = WEIGHT_TYPE.newInstance(this);
    wgtVec <== (c === 0)
      ? wgtInpVec
      : wgtBuf.read(wgtBufAddr);

    int i = 0;
    for (int dx = KERNEL_LOWER; dx <= KERNEL_UPPER; dx ++) {
      for (int dy = KERNEL_LOWER; dy <= KERNEL_UPPER; dy ++) {
        // conditions {{{

        DFEVar aboveUpper = rx + dx >= H | ry + dy >= W;
        DFEVar belowLower = rx + dx <  0 | ry + dy <  0;
        DFEVar outOfBound = (aboveUpper | belowLower);
        DFEVar readEnable = inpEnable;

        // }}}
        // address {{{

        // transform 2d coordinates to 1d vector indices
        DFEVar readInpBufAddr  = (rx + dx) * H + (ry + dy);
        readInpBufAddr = readInpBufAddr.cast(dfeUInt(INPUT_BUF_ADDR_BITS));

        // }}}
        // read {{{

        // read from stream only when f == 0
        DFEVar curr = (outOfBound)
          ? constant.var(0)
          : ((readEnable) 
              ? stream.offset(inp, dx * W + dy)
              : inputBuf.read(readInpBufAddr));

        // }}}
        // weight {{{

        DFEVar wgt = wgtVec[(dx - KERNEL_LOWER) * K + (dy - KERNEL_LOWER)];

        // }}}
        // output {{{
       
        window[i ++] = curr * wgt;

        // }}}
      }
    }

    // }}}
    // Window Sum and the Feedback Loop {{{

    // initialise with bias
    DFEVar windowSum = (c === 0) ? bias : constant.var(0);
    
    for (DFEVar windowElem: window)
      // TODO: check maxpower solution
      windowSum = windowSum + windowElem;

    // TODO: seek better solution
    // this implements a output buffer that stores partial result
    DFEVar result = DATA_TYPE.newInstance(this);
    result <== outputBuf.port(
        writeOutBufAddr, // read and write address
        (windowSum +
        ((c === 0) 
         ? constant.var(0) 
         : stream.offset(result, -OUTPUT_BUF_SIZE))), // dependency
        c >= 0,
        Mem.RamWriteMode.WRITE_FIRST);
        
    // }}}
    // Output Stream {{{

    DFEVar optEnable = (
        (c === C - 1) &
        (sx === OUTPUT_SX & sy === OUTPUT_SY) &
        (rx + KERNEL_LOWER >= -P & rx + KERNEL_UPPER <= H + P - 1) &
        (ry + KERNEL_LOWER >= -P & ry + KERNEL_UPPER <= W + P - 1));
    io.output(CONV_OUT_NAME, result, DATA_TYPE, optEnable);
    
    // }}}
  }
}
