package maxdeep.kernels;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * Reshape parallelised output.
 *
 * Previous input are in the wrong order, needs to be reshaped.
 * Each cycle this kernel will generate one output from one filter 
 * in sequance
 *
 * @author Ruizhe Zhao <ruizhe.zhao15@imperial.ac.uk>
 * @since  2017-01-03
 */
public class ConvOutputKernel extends Kernel {

  public static final String INP_NAME  = "inp";
  public static final String OUT_NAME  = "opt";

  private static final DFEType DATA_TYPE = dfeFloat(8, 24);

  public ConvOutputKernel(KernelParameters params,
      int L,  /* length of the buffer */
      int F,  /* number of filters */
      int P_F /* parallel in filter */
  ) {
    super(params);

    int MUX_BITS = MathUtils.bitsToAddress(P_F);

    // Counters {{{

    CounterChain chain = control.count.makeCounterChain();
    DFEVar f = chain.addCounter(F, P_F).cast(dfeInt(32));
    DFEVar p = (P_F == 1)
      ? constant.var(0) : chain.addCounter(P_F, 1).cast(dfeInt(32));
    DFEVar l = chain.addCounter(L, 1).cast(dfeInt(32));

    // f.simWatch("f");
    // p.simWatch("p");
    // l.simWatch("l");

    // }}}
    // Vector type {{{

    DFEVectorType<DFEVar> VEC_TYPE =
      new DFEVectorType<DFEVar>(DATA_TYPE, P_F);

    // }}}
    // Buffer {{{

    // There is only one buffer that stores vectors.
    int BUF_SIZE = F * L / P_F;
    int BUF_ADDR_BITS = MathUtils.bitsToAddress(BUF_SIZE);
    Memory<DFEVector<DFEVar>> buf = mem.alloc(VEC_TYPE, BUF_SIZE);

    // }}}
    // Control {{{

    // current filter index
    DFEVar cf = f + p; 

    // write address
    DFEVar wf = (f + p) * P_F;

    // write enable: only when the the write address is smaller than
    // the number of all filters
    DFEVar writeEnable = (wf < F);

    // }}}
    // Input stream {{{

    DFEVector<DFEVar> inp = io.input(INP_NAME, VEC_TYPE, writeEnable);

    // }}}
    // Buffer write {{{

    DFEVar addr = (cf * L + l).cast(dfeUInt(BUF_ADDR_BITS));
    buf.write(addr, inp, writeEnable);

    // }}}
    // Buffer read and output {{{

    DFEVector<DFEVar> bufVec = VEC_TYPE.newInstance(this);
    bufVec <== buf.read((f / P_F * L + l).cast(dfeUInt(BUF_ADDR_BITS)));
    DFEVar [ ] bufVecList = new DFEVar [ P_F ];
    for (int i = 0; i < P_F; i ++)
      bufVecList[ i ] = bufVec[i];

    DFEVar bufRead = DATA_TYPE.newInstance(this);
    if (P_F != 1) 
      bufRead <== control.mux(p.cast(dfeUInt(MUX_BITS)), bufVecList);
    else
      bufRead <== bufVecList[0]; 
    // bufRead.simWatch("bufRead");
    
    DFEVar output = (cf === 0 | P_F == 1) ? inp[0] : bufRead;
    io.output(OUT_NAME, output, DATA_TYPE);

    // }}}
  }
}
