package maxdeep.kernels;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;

/**
 * The pooling layer for the CNN network
 * @author Ruizhe Zhao <ruizhe.zhao15@imperial.ac.uk>
 */
public class PoolingLayerKernel extends Kernel {

  public static final String INP_NAME = "inp";
  public static final String OUT_NAME = "opt";

  private static final DFEType COUNTER_TYPE = dfeInt(32);
  private static final DFEType DATA_TYPE = dfeFloat(8, 24);

  public PoolingLayerKernel(
      KernelParameters params,
      int H,
      int W,
      int C,
      int K,
      int P,
      int S /* stride */
  ) {
    super(params);
    // Constants {{{

    int KERNEL_UPPER = K / 2;
    int KERNEL_LOWER = - K / 2;
    int OUTPUT_SX    = (- KERNEL_LOWER - P) % S;
    int OUTPUT_SY    = (- KERNEL_LOWER - P) % S;

    if (K % 2 == 0)
      KERNEL_UPPER --;

    // }}}
    // Counters {{{

    CounterChain chain = control.count.makeCounterChain();
    if (C != 1)
      chain.addCounter(C, 1).cast(COUNTER_TYPE);
    DFEVar x  = chain.addCounter(H, S).cast(dfeInt(32));
    DFEVar sx = (S == 1)
      ? constant.var(0) : chain.addCounter(S, 1).cast(dfeInt(32));
    DFEVar y  = chain.addCounter(W, S).cast(dfeInt(32));
    DFEVar sy = (S == 1)
      ? constant.var(0) : chain.addCounter(S, 1).cast(dfeInt(32));
    DFEVar rx = x + sx;
    DFEVar ry = y + sy;

    // }}}
    // Input Stream {{{

    DFEVar inp = io.input(INP_NAME, DATA_TYPE);

    // }}}
    // Window {{{
    
    DFEVar maxVal = inp;
    for (int dx = KERNEL_LOWER; dx <= KERNEL_UPPER; dx ++) {
      for (int dy = KERNEL_LOWER; dy <= KERNEL_UPPER; dy ++) {
        DFEVar aboveUpper = rx + dx >= H | ry + dy >= W;
        DFEVar belowLower = rx + dx <  0 | ry + dy <  0;
        DFEVar outOfBound = (aboveUpper | belowLower);
        DFEVar curr = stream.offset(inp, dx * W + dy);
        
        maxVal = (maxVal < curr & ~outOfBound) ? curr : maxVal;
      }
    }
    // }}}
    // Output {{{

    DFEVar optEnable = (
        (sx === OUTPUT_SX) &
        (sy === OUTPUT_SY) &
        (rx + KERNEL_LOWER >= -P) &
        (rx + KERNEL_UPPER <= H + P) &
        (ry + KERNEL_LOWER >= -P) &
        (ry + KERNEL_UPPER <= W + P));

    io.output(OUT_NAME, maxVal, DATA_TYPE, optEnable);

    // }}}
  }
}
