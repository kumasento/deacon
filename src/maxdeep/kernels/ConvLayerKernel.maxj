package maxdeep.kernels;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * The convolution layer for the CNN network
 * @author Ruizhe Zhao <ruizhe.zhao15@imperial.ac.uk>
 */
public class ConvLayerKernel extends Kernel {

  public static final String CONV_INP_NAME = "conv_inp";
  public static final String CONV_WGT_NAME = "conv_wgt";
  public static final String CONV_OUT_NAME = "conv_out";

  private static final DFEType DATA_TYPE = dfeFloat(8, 24);

  public ConvLayerKernel(KernelParameters params,
      int H, /* height of the input feature map */
      int W, /* width of the input feature map */
      int F, /* number of output filters */
      int C, /* number of input feature map channels */
      int K  /* kernel size */
      )
  {
    super(params);

    // Constants {{{
    // input buffer stores a feature map for a single channel
    int KERNEL_UPPER         =   K / 2;
    int KERNEL_LOWER         = - K / 2;
    int INPUT_BUF_SIZE       = H * W;
    int OUTPUT_BUF_SIZE      = H * W * F;
    int WEIGHT_BUF_SIZE      = F;
    int INPUT_BUF_ADDR_BITS  = MathUtils.bitsToAddress(INPUT_BUF_SIZE);
    int OUTPUT_BUF_ADDR_BITS = MathUtils.bitsToAddress(OUTPUT_BUF_SIZE);
    int WEIGHT_BUF_ADDR_BITS = MathUtils.bitsToAddress(WEIGHT_BUF_SIZE);
    // }}}
    // Counter {{{
    CounterChain chain = control.count.makeCounterChain();
    DFEVar c = (C == 1) ? constant.var(0) : chain.addCounter(C, 1).cast(dfeInt(32));
    DFEVar f = chain.addCounter(F, 1).cast(dfeInt(32));
    DFEVar x = chain.addCounter(H, 1).cast(dfeInt(32));
    DFEVar y = chain.addCounter(W, 1).cast(dfeInt(32));
    // }}}
    // Input Stream {{{
    DFEVar inpEnable = (f === 0).cast(dfeBool());
    DFEVar inp = io.input(CONV_INP_NAME, DATA_TYPE, inpEnable);

    // only read weight vector at the begining of the first channel's
    // computation
    DFEVar wgtEnable = (c === 0 & x === 0 & y === 0);
    DFEVectorType<DFEVar> WEIGHT_TYPE = 
      new DFEVectorType<DFEVar>(DATA_TYPE, K * K);
    DFEVector<DFEVar> wgtInpVec = io.input(CONV_WGT_NAME, WEIGHT_TYPE, wgtEnable); 
    // }}}
    // Input Buffer {{{
    Memory<DFEVar> inputBuf = mem.alloc(DATA_TYPE, INPUT_BUF_SIZE);

    DFEVar writeInpBufAddr = (x * H + y);
    writeInpBufAddr = writeInpBufAddr.cast(dfeUInt(INPUT_BUF_ADDR_BITS));
    inputBuf.write(writeInpBufAddr, inp, inpEnable);
    // }}}
    // Weight buffer {{{
    Memory<DFEVector<DFEVar>> wgtBuf = mem.alloc(WEIGHT_TYPE, WEIGHT_BUF_SIZE);
    DFEVar wgtBufAddr = (f * K * K).cast(dfeUInt(WEIGHT_BUF_ADDR_BITS));

    wgtBuf.write(wgtBufAddr, wgtInpVec, wgtEnable);
    // }}}
    // Output Buffer {{{
    Memory<DFEVar> outputBuf = mem.alloc(DATA_TYPE, OUTPUT_BUF_SIZE);

    DFEVar writeOutBufAddr = (f * H * W + x * H + y).cast(dfeUInt(OUTPUT_BUF_ADDR_BITS));
    // }}}
    // Create Convolution Window {{{
    // a window of kernel
    DFEVar window [] = new DFEVar [K * K]; 

    DFEVector<DFEVar> wgtVec = WEIGHT_TYPE.newInstance(this);
    wgtVec <== (c === 0)
      ? wgtInpVec
      : wgtBuf.read(wgtBufAddr);

    int i = 0;
    for (int dx = KERNEL_LOWER; dx <= KERNEL_UPPER; dx ++) {
      for (int dy = KERNEL_LOWER; dy <= KERNEL_UPPER; dy ++) {
        // conditions {{{
        DFEVar aboveUpper = x + dx >= H | y + dy >= W;
        DFEVar belowLower = x + dx <  0 | y + dy <  0;
        DFEVar outOfBound = (aboveUpper | belowLower);
        DFEVar readEnable = inpEnable;
        // }}}
        // address {{{
        // transform 2d coordinates to 1d vector indices
        DFEVar readInpBufAddr  = (x + dx) * H + (y + dy);
        readInpBufAddr = readInpBufAddr.cast(dfeUInt(INPUT_BUF_ADDR_BITS));
        // }}}
        // read {{{
        // read from stream only when f == 0
        DFEVar curr = (outOfBound)
          ? constant.var(0)
          : ((readEnable) 
              ? stream.offset(inp, dx * W + dy)
              : inputBuf.read(readInpBufAddr));
        // }}}
        // weight {{{
        DFEVar wgt = wgtVec[(dx - KERNEL_LOWER) * K + (dy - KERNEL_LOWER)];
        // }}}
        // output {{{
        window[i ++] = curr * wgt;
        // }}}
      }
    }
    // }}}
    // Window Sum and the Feedback Loop {{{
    // sum up all the kernel elements (assume weights are all 1)
    DFEVar windowSum = constant.var(DATA_TYPE, 0);
    for (DFEVar windowElem: window)
      // TODO: check maxpower solution
      windowSum = windowSum + windowElem;

    // TODO: seek better solution
    // this implements a output buffer that stores partial result
    DFEVar result = DATA_TYPE.newInstance(this);
    result <== outputBuf.port(
        writeOutBufAddr, // read and write address
        (windowSum +
        ((c === 0) 
         ? constant.var(0) 
         : stream.offset(result, -OUTPUT_BUF_SIZE))), // dependency
        c >= 0,
        Mem.RamWriteMode.WRITE_FIRST);
        
    // }}}
    // Output Stream {{{
    io.output(CONV_OUT_NAME, result, DATA_TYPE, c === C - 1);
    // }}}
  }
}
