package maxdeep.kernels;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

import java.util.*;

/**
 * The accumulator for the output from the convolve kernel 
 * @author Ruizhe Zhao <ruizhe.zhao15@imperial.ac.uk>
 */
public class ConvAccumKernel extends Kernel {

  public static final String OUT_NAME  = "opt";
  public static final String BIAS_NAME = "bias";

  public static final String CONV_KNL_OUT_NAME = "conv_knl_opt";

  public ConvAccumKernel(KernelParameters params,
      int H,   /* height of the input feature map */
      int W,   /* width of the input feature map */
      int F,   /* number of output filters */
      int C,   /* number of input feature map channels */
      int K,   /* kernel size */
      int P,   /* padding size */
      int S,   /* stride size */
      int P_F, /* parallel in filter */
      DFEType DATA_TYPE
  ) {
    super(params);

    // Constants {{{

    // input buffer stores a feature map for a single channel
    int KERNEL_UPPER         =   K / 2;
    int KERNEL_LOWER         = - K / 2;
    int BIAS_BUF_SIZE        = F;
    int BIAS_BUF_ADDR_BITS   = MathUtils.bitsToAddress(BIAS_BUF_SIZE);
    int OUTPUT_BUF_SIZE      = H * W * F / P_F;
    int OUTPUT_BUF_ADDR_BITS = MathUtils.bitsToAddress(OUTPUT_BUF_SIZE);
    int OUTPUT_SX            = (- KERNEL_LOWER - P) % S;
    int OUTPUT_SY            = (- KERNEL_LOWER - P) % S;

    if (K % 2 == 0)
      KERNEL_UPPER --;

    // vector type
    DFEVectorType<DFEVar> VEC_TYPE =
      new DFEVectorType<DFEVar>(DATA_TYPE, P_F);

    // }}}
    // Counter {{{
    
    CounterChain chain = control.count.makeCounterChain();
    DFEVar c  = (C == 1)
      ? constant.var(0)
      : chain.addCounter(C, 1).cast(dfeInt(32));
    DFEVar f  = (F == 1)
      ? constant.var(0)
      : chain.addCounter(F, P_F).cast(dfeInt(32));
    DFEVar x  = chain.addCounter(H, S).cast(dfeInt(32));
    DFEVar sx = (S == 1)
      ? constant.var(0)
      : chain.addCounter(S, 1).cast(dfeInt(32));
    DFEVar y  = chain.addCounter(W, S).cast(dfeInt(32));
    DFEVar sy = (S == 1)
      ? constant.var(0)
      : chain.addCounter(S, 1).cast(dfeInt(32));
    DFEVar rx = x + sx;
    DFEVar ry = y + sy;

    // c.simWatch("c");
    // f.simWatch("f");
    // rx.simWatch("rx");
    // ry.simWatch("ry");

    // }}}
    // Bias buffer {{{

    Memory<DFEVar> bias = mem.alloc(DATA_TYPE, BIAS_BUF_SIZE);
    bias.mapToCPU(BIAS_NAME);
    
    // }}}
    // Output Buffer {{{

    ArrayList<Memory<DFEVar>> optBufList = new ArrayList<Memory<DFEVar>>();
    for (int i = 0; i < P_F; i ++)
      optBufList.add(mem.alloc(DATA_TYPE, OUTPUT_BUF_SIZE));

    // }}}
    // Window Sum and the Feedback Loop {{{

    DFEVector<DFEVar> output = VEC_TYPE.newInstance(this);
    
    for (int idx = 0; idx < P_F; idx ++) {

      DFEVar biasReadAddr = (f + idx).cast(dfeUInt(BIAS_BUF_ADDR_BITS));

      DFEVar writeOutBufAddr = ((f / P_F) * H * W + rx * H + ry)
        .cast(dfeUInt(OUTPUT_BUF_ADDR_BITS));

      DFEVar tmp = io.input(
          CONV_KNL_OUT_NAME + "_" + Integer.toString(idx),
          DATA_TYPE);
      // tmp.simWatch("tmp");

      // initialise with bias
      DFEVar sum = (c === 0) ? bias.read(biasReadAddr) + tmp : tmp;
      
      // TODO: seek better solution
      // this implements a output buffer that stores partial result
      DFEVar result = DATA_TYPE.newInstance(this);
      result <== optBufList[ idx ].port(
          writeOutBufAddr, // read and write address
          (sum +
          ((c === 0) 
           ? constant.var(0) 
           : stream.offset(result, -OUTPUT_BUF_SIZE))), // dependency
          c >= 0,
          Mem.RamWriteMode.WRITE_FIRST);
      // result.simWatch("result_" + Integer.toString(idx));
          
      // connect to the output vector
      output[idx] <== result;
    }
    // }}}
    // Output Stream {{{

    DFEVar optEnable = (
        (c === C - 1) &
        (sx === OUTPUT_SX) &
        (sy === OUTPUT_SY) &
        (rx + KERNEL_LOWER >= -P) &
        (rx + KERNEL_UPPER <= H + P - 1) &
        (ry + KERNEL_LOWER >= -P) &
        (ry + KERNEL_UPPER <= W + P - 1));

    io.output(OUT_NAME, output, VEC_TYPE, optEnable);

    // }}}
  }
}
