package maxdeep.kernels;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

import java.util.*;

/**
 * The computation kernel that focuses on computing convolution.
 *
 * This kernel has no buffer, no complicated loop control. It just takes
 * input and weight of size k*k from the ConvLayerKernel and send back a 
 * convolution result.
 *
 * @author Ruizhe Zhao <ruizhe.zhao15@imperial.ac.uk>
 * @since  2017-01-03
 */
public class ConvolveKernel extends Kernel {

  public static final String INP_NAME = "inp";
  public static final String WGT_NAME = "wgt";
  public static final String OUT_NAME = "opt";

  public ConvolveKernel(KernelParameters params,
    int K, /* kernel size */
    int P_F_MP,
    DFEType DATA_TYPE
  ) {
    super(params);
    
    CounterChain chain = control.count.makeCounterChain();
    DFEVar c = (P_F_MP == 1)
      ? constant.var(0)
      : chain.addCounter(P_F_MP, 1).cast(dfeInt(32));
    int CLK_BITS = MathUtils.bitsToAddress(P_F_MP);

    // vector type for inp and wgt
    DFEVectorType<DFEVar> VEC_TYPE =
      new DFEVectorType<DFEVar>(DATA_TYPE, K * K);
    
    ArrayList<DFEVector<DFEVar>> inpList =
      new ArrayList<DFEVector<DFEVar>>();
    ArrayList<DFEVector<DFEVar>> wgtList =
      new ArrayList<DFEVector<DFEVar>>();

    for (int i = 0; i < P_F_MP; i ++) {
      String suf = "_" + Integer.toString(i);
      inpList.add(io.input(INP_NAME + suf, VEC_TYPE, c === i));
      wgtList.add(io.input(WGT_NAME + suf, VEC_TYPE, c === i));
    }
    
    DFEVector<DFEVar> inp = (P_F_MP == 1)
      ? inpList[0]
      : control.mux(c.cast(dfeUInt(CLK_BITS)), inpList);

    DFEVector<DFEVar> wgt = (P_F_MP == 1)
      ? wgtList[0]
      : control.mux(c.cast(dfeUInt(CLK_BITS)), wgtList);

    // window to store temporary result
    ArrayList<DFEVar> window = new ArrayList<DFEVar>();

    // window index
    for (int x = 0; x < K; x ++)
      for (int y = 0; y < K; y ++) 
        window.add(wgt[x * K + y] * inp[x * K + y]);

    DFEVar sum = windowSum(window);

    // sum.simWatch("sum");
    for (int i = 0; i < P_F_MP; i ++) {
      String suf = "_" + Integer.toString(i);
      io.output(OUT_NAME + suf, sum, DATA_TYPE, c === i);
    }
  }

  private DFEVar windowSum(List<DFEVar> window) {
    // sum up
    int layerIdx = 0; // layer
    int startIdx = 0;
    int length = window.size();
    while (length > 1) {
      int i;
      int newLength = (int) Math.floor((double) length/2);
      for (i = 0; i < newLength; i ++)
      {
        DFEVar fst = window[startIdx + i * 2];
        DFEVar snd = window[startIdx + i * 2 + 1];
        DFEVar res = fst + snd;
        window.add(res);
      }
      if (i * 2 == length - 1) {
        newLength += 1;
        window.add(window[startIdx + i * 2]);
      }
      System.out.println("Current layer idx is: " + Integer.toString(layerIdx));
      System.out.println("length is:            " + Integer.toString(length));
      System.out.println("new length is:        " + Integer.toString(newLength));

      startIdx += length;
      layerIdx += 1;
      length = newLength;
    }

    return window[window.size()-1];
  }
}
