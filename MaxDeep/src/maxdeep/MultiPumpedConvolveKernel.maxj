package maxdeep;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

import maxpower.kernel.KernelBinaryOp.*;
import maxpower.utils.TreeReduce;

import java.util.*;

/**
 * NOTE: updated MultiPumpedConvolveKernel from KernelLib to Kernel
 * (2017-02-27) Ruizhe Zhao
 */

class MultiPumpedConvolveKernel extends Kernel {

  public static final String INP_NAME = "MPC_INP";
  public static final String WGT_NAME = "MPC_WGT";
  public static final String OUT_NAME = "MPC_OUT";
  public static final String SCALAR_KERNEL_SIZE_NAME = "MPC_SCALAR_KERNEL_SIZE";

  public static final DFEType DATA_TYPE = dfeUInt(32);

  /**
   * Constructor for the MultiPumpedConvolveKernel 
   *   
   * @param params kernel parameters provided by Manager
   * @param N the number of parallelised convolvers
   * @param maxKernelSize the shape of the convolve kernel
   * @param C the multi-pumping factor 
   * @param dbg The flag to use DEBUG mode
   */
  public MultiPumpedConvolveKernel(
    KernelParameters params,
    int N,
    int maxKernelSize,
    int C,
    boolean dbg
  ) {
    super(params);

    if (C <= 0) 
      throw new IllegalArgumentException("C should be larger than or equal to 1.");

    if (C > N)
      throw new IllegalArgumentException("C should not be larger than N.");

    if (N % C != 0)
      throw new IllegalArgumentException("C should not be divisible by N.");

    DFEVar c = control.count.simpleCounter(32, C);
    if (C > 1)
      c = c.cast(dfeUInt(MathUtils.bitsToAddress(C)));

    /**
     * Main multi-pumping control logic
     */
    // M is the real number of pipes after multi-pumping
    int M = N / C;

    // c is the value of the counter for the current cycle
    // in the multi-pumping computation.
    // If C is 1, then c will always be 0
    // If C is larger than 1, c will count from 0 to C - 1.
    // DFEVar c = control.count.simpleCounter(32, C);

    /**
     * Optimisation configuration:
     * The pipeling and DSP factor will be fully used.
     */
    optimization.pushPipeliningFactor(1.0);
    optimization.pushDSPFactor(1);

    /**
     * Scalar inputs:
     * - kernelSize: the size of the kernel in the current computation
     */
    DFEVar kernelSize = io.scalarInput(SCALAR_KERNEL_SIZE_NAME, DATA_TYPE);

    /**
     * Input:
     * The input vector of the MPC kernel. For each convolver, this vector
     * will give K * K elements.
     */
    int inpVecSize = maxKernelSize * maxKernelSize * M;
    int inpTotalVecSize = inpVecSize * C;

    DFEVectorType<DFEVar> inpVecType
      = new DFEVectorType<DFEVar>(DATA_TYPE, inpVecSize);
    DFEVectorType<DFEVar> inpTotalVecType
      = new DFEVectorType<DFEVar>(DATA_TYPE, inpTotalVecSize);

    DFEVector<DFEVar> inpTotalVec = io.input(INP_NAME, inpTotalVecType, c === 0);
    DFEVector<DFEVar> inpVec = inpVecType.newInstance(this);

    for (int i = 0; i < maxKernelSize * maxKernelSize * M; i ++) {
      if (C == 1)
        inpVec[i] <== inpTotalVec[i];
      else {
        List<DFEVar> inpList = new ArrayList<DFEVar>();
        for (int j = 0; j < C; j ++)
          inpList.add(inpTotalVec[j * M + i]);
        inpVec[i] <== control.mux(c, inpList);
      }
    }

    /**
     * Weight:
     * The weight vector for the computation of each cycle. Same size 
     * as the input vector, which will be easier to handle in this case.
     */
    int wgtVecSize = maxKernelSize * maxKernelSize * M;
    int wgtTotalVecSize = wgtVecSize * C;
    DFEVectorType<DFEVar> wgtTotalVecType
      = new DFEVectorType<DFEVar>(DATA_TYPE, wgtTotalVecSize);
    DFEVectorType<DFEVar> wgtVecType
      = new DFEVectorType<DFEVar>(DATA_TYPE, wgtVecSize);
    DFEVector<DFEVar> wgtTotalVec = io.input(WGT_NAME, wgtTotalVecType, c === 0);
    DFEVector<DFEVar> wgtVec = wgtVecType.newInstance(this);
    for (int i = 0; i < maxKernelSize * maxKernelSize * M; i ++) {
      if (C == 1)
        wgtVec[i] <== wgtTotalVec[i];
      else {
        List<DFEVar> wgtList = new ArrayList<DFEVar>();
        for (int j = 0; j < C; j ++)
          wgtList.add(wgtTotalVec[j * M + i]);

        wgtVec[i] <== control.mux(c, wgtList);
      }
    }

    /**
     * Output:
     * The output vector of this MPC kernel.
     */
    int outVecSize = M;
    int outTotalVecSize = N;

    DFEVectorType<DFEVar> outVecType =
      new DFEVectorType<DFEVar>(DATA_TYPE, outVecSize);
    DFEVectorType<DFEVar> outTotalVecType =
      new DFEVectorType<DFEVar>(DATA_TYPE, outTotalVecSize);

    DFEVector<DFEVar> outVec = outVecType.newInstance(this);
    DFEVector<DFEVar> outTotalVec = outTotalVecType.newInstance(this);

    /**
     * Computation:
     * Treat the whole kernel as a collection of multiple one-cycle 
     * dot products.
     * window stores the element-wise multiplication result.
     */
    DFEVectorType<DFEVar> windowType =
      new DFEVectorType<DFEVar>(DATA_TYPE, maxKernelSize * maxKernelSize);
    for (int idx = 0; idx < outVecSize; idx ++) {
      DFEVector<DFEVar> window = windowType.newInstance(this);

      int maxKernelArea = maxKernelSize * maxKernelSize;
      // DFEVar kernelArea = kernelSize * kernelSize;
      
      for (int i = 0; i < maxKernelArea; i ++) {
        // DFEVar dfeI = constant.var(i).cast(dfeUInt(32));
        /**
         * NOTE: There is a timing issue in the comparison node, which I think might due
         * to the kernelArea's fanout. Here I add a level of pipelining to replicate
         * this DFEVar manually.
         * (2017-03-13) Ruizhe Zhao
         */
        // DFEVar kernelAreaPipelined = optimization.pipeline(kernelArea);

        // assign the value to be 0 if it is out of bound.
        window[i] <== (inpVec[i + idx * maxKernelArea] * wgtVec[i + idx * maxKernelArea]);
      }

      outVec[idx] <== TreeReduce.reduce(new Add(), window.getElementsAsList()); 
    }

    for (int i = 0; i < C; i ++) {
      for (int j = 0; j < M; j ++) {
        DFEVector<DFEVar> out = stream.offset(outVec, -i);
        outTotalVec[i * M + j] <== out[j];
      }
    }

    io.output(OUT_NAME, outTotalVec, outTotalVecType, c === C - 1);

    if (dbg) {
      DFEVar t = control.count.simpleCounter(32);
      debug.simPrintf("%d - inp %KObj%\n", t, inpVec);
      debug.simPrintf("%d - wgt %KObj%\n", t, wgtVec);
      debug.simPrintf("%d - [\n", t);
      for (int kx = 0; kx < maxKernelSize; kx ++) {
        debug.simPrintf("  [ ");
        for (int ky = 0; ky < maxKernelSize - 1; ky ++)
          debug.simPrintf("%3d, ", inpVec[kx * maxKernelSize + ky]);
        debug.simPrintf("%3d ]\n", inpVec[kx * maxKernelSize + maxKernelSize - 1]);
      }
      debug.simPrintf("]\n");
      debug.simPrintf("%d - out %KObj%\n", t, outVec);
    }
  }
}
