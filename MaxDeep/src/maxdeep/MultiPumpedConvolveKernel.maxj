package maxdeep;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

import com.custom_computing_ic.dfe_snippets.utils.Reductions;

/**
 * NOTE: updated MultiPumpedConvolveKernel from KernelLib to Kernel
 * (2017-02-27) Ruizhe Zhao
 */

class MultiPumpedConvolveKernel extends Kernel {

  public static final String INP_NAME = "MPC_INP";
  public static final String WGT_NAME = "MPC_WGT";
  public static final String OUT_NAME = "MPC_OUT";

  public static final DFEType DATA_TYPE = dfeUInt(32);

  /**
   * Constructor for the MultiPumpedConvolveKernel 
   *   
   * @param params kernel parameters provided by Manager
   * @param N the number of parallelised convolvers
   * @param K the shape of the convolve kernel
   * @param C the multi-pumping factor 
   * @param dbg The flag to use DEBUG mode
   */
  public MultiPumpedConvolveKernel(
    KernelParameters params,
    int N,
    int K,
    int C,
    boolean dbg
  ) {
    super(params);

    optimization.pushPipeliningFactor(1.0);
    optimization.pushDSPFactor(1);

    int inpVecSize = K * K * N / C;
    int wgtVecSize = K * K * N / C;
    int outVecSize = N / C;

    DFEVectorType<DFEVar> inpVecType =
      new DFEVectorType<DFEVar>(DATA_TYPE, inpVecSize);
    DFEVectorType<DFEVar> wgtVecType =
      new DFEVectorType<DFEVar>(DATA_TYPE, wgtVecSize);
    DFEVectorType<DFEVar> outVecType =
      new DFEVectorType<DFEVar>(DATA_TYPE, outVecSize);
    DFEVectorType<DFEVar> windowType =
      new DFEVectorType<DFEVar>(DATA_TYPE, K * K);

    DFEVector<DFEVar> inpVec = io.input(INP_NAME, inpVecType);
    DFEVector<DFEVar> wgtVec = io.input(WGT_NAME, wgtVecType);
    DFEVector<DFEVar> outVec = outVecType.newInstance(this);


    if (dbg) {
      debug.simPrintf("[\n");
      for (int kx = 0; kx < K; kx ++) {
        debug.simPrintf("  [ ");
        for (int ky = 0; ky < K - 1; ky ++)
          debug.simPrintf("%3d, ", inpVec[kx * K + ky]);
        debug.simPrintf("%3d ]\n", inpVec[kx * K + K - 1]);
      }
      debug.simPrintf("]\n");
    }

    for (int idx = 0; idx < outVecSize; idx ++) {
      DFEVector<DFEVar> window = windowType.newInstance(this);

      for (int i = 0; i < K * K; i ++)
        window[i] <== inpVec[i + idx * K * K] * wgtVec[i + idx * K * K];

      outVec[idx] <== Reductions.reduce(window); 
    }

    io.output(OUT_NAME, outVec, outVecType);
  }
}
