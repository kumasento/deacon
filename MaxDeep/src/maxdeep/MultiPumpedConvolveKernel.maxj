package maxdeep;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;

import com.custom_computing_ic.dfe_snippets.utils.Reductions;

/**
 * NOTE: updated MultiPumpedConvolveKernel from KernelLib to Kernel
 * (2017-02-27) Ruizhe Zhao
 */

class MultiPumpedConvolveKernel extends Kernel {

  public static final String INP_NAME = "MPC_INP";
  public static final String WGT_NAME = "MPC_WGT";
  public static final String OUT_NAME = "MPC_OUT";
  public static final String SCALAR_KERNEL_SIZE_NAME = "MPC_SCALAR_KERNEL_SIZE";

  public static final DFEType DATA_TYPE = dfeUInt(32);

  /**
   * Constructor for the MultiPumpedConvolveKernel 
   *   
   * @param params kernel parameters provided by Manager
   * @param N the number of parallelised convolvers
   * @param maxKernelSize the shape of the convolve kernel
   * @param C the multi-pumping factor 
   * @param dbg The flag to use DEBUG mode
   */
  public MultiPumpedConvolveKernel(
    KernelParameters params,
    int N,
    int maxKernelSize,
    int C,
    boolean dbg
  ) {
    super(params);

    optimization.pushPipeliningFactor(1.0);
    optimization.pushDSPFactor(1);

    DFEVar kernelSize = io.scalarInput(SCALAR_KERNEL_SIZE_NAME, DATA_TYPE);

    int inpVecSize = maxKernelSize * maxKernelSize * N / C;
    int wgtVecSize = maxKernelSize * maxKernelSize * N / C;
    int outVecSize = N / C;

    DFEVectorType<DFEVar> inpVecType =
      new DFEVectorType<DFEVar>(DATA_TYPE, inpVecSize);
    DFEVectorType<DFEVar> wgtVecType =
      new DFEVectorType<DFEVar>(DATA_TYPE, wgtVecSize);
    DFEVectorType<DFEVar> outVecType =
      new DFEVectorType<DFEVar>(DATA_TYPE, outVecSize);
    DFEVectorType<DFEVar> windowType =
      new DFEVectorType<DFEVar>(DATA_TYPE, maxKernelSize * maxKernelSize);

    DFEVector<DFEVar> inpVec = io.input(INP_NAME, inpVecType);
    DFEVector<DFEVar> wgtVec = io.input(WGT_NAME, wgtVecType);
    DFEVector<DFEVar> outVec = outVecType.newInstance(this);

    if (dbg) {
      debug.simPrintf("[\n");
      for (int kx = 0; kx < maxKernelSize; kx ++) {
        debug.simPrintf("  [ ");
        for (int ky = 0; ky < maxKernelSize - 1; ky ++)
          debug.simPrintf("%3d, ", inpVec[kx * maxKernelSize + ky]);
        debug.simPrintf("%3d ]\n", inpVec[kx * maxKernelSize + maxKernelSize - 1]);
      }
      debug.simPrintf("]\n");
    }

    for (int idx = 0; idx < outVecSize; idx ++) {
      DFEVector<DFEVar> window = windowType.newInstance(this);

      int maxKernelArea = maxKernelSize * maxKernelSize;
      DFEVar kernelArea = kernelSize * kernelSize;
      for (int i = 0; i < maxKernelArea; i ++) {
        DFEVar dfeI = constant.var(i).cast(dfeUInt(32));
        window[i] <==
          (dfeI < kernelArea)
          ? (inpVec[i + idx * maxKernelArea] * wgtVec[i + idx * maxKernelArea])
          : constant.var(0);
      }

      outVec[idx] <== Reductions.reduce(window); 
    }

    io.output(OUT_NAME, outVec, outVecType);
  }
}
