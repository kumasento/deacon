package maxdeep;

// import com.maxeler.maxcompiler.v2.build.EngineParameters;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;
// import com.maxeler.maxcompiler.v2.managers.custom.CustomManager.LMemFrequency;
import com.maxeler.maxcompiler.v2.managers.custom.ManagerClock;
// import com.maxeler.maxcompiler.v2.managers.custom.DFELink;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelConfiguration;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.KernelBlock;
import com.maxeler.maxcompiler.v2.managers.custom.stdlib.LMemInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceMath;
import com.maxeler.maxcompiler.v2.managers.custom.stdlib.MemoryControllerConfig;
import com.maxeler.maxcompiler.v2.managers.BuildConfig;

import com.custom_computing_ic.dfe_snippets.manager.ManagerUtils;

class MaxDeepManager extends CustomManager {

  // private static final String MAXDEEP_KERNEL_NAME
  //   = "MaxDeepKernel";
  private static final String MULTI_PUMPED_CONVOLVE_KERNEL_NAME
    = "MultiPumpedConvolveKernel";
  private static final String CONV_CACHE_KERNEL_NAME
    = "ConvolutionLayerCacheKernel";
  private static final String CONV_POST_PROCESS_KERNEL_NAME
    = "ConvolutionLayerPostProcessKernel";
  private static final String MULTI_PUMPED_DOT_PRODUCT_KERNEL_NAME
    = "MultiPumpedDotProductKernel";
  private static final String FC_CACHE_KERNEL_NAME
    = "FullyConnectedLayerCacheKernel";
  private static final String FC_POST_PROCESS_KERNEL_NAME
    = "FullyConnectedLayerPostProcessKernel";
  private static final String PADDING_KERNEL_NAME
    = "PaddingKernelConvolution";
  private static final String PADDING_KERNEL_FC_NAME
    = "PaddingKernelFullyConnected";
  
  private static final String DEFAULT_KERNEL_CLK = "DefaultKernelClock";
  private static final String MULTI_PUMPED_KERNEL_CLK = "MultiPumpedKernelClock";

  private final int N;
  private final int C;
  private final int freq;
  private final int maxConvHeight;
  private final int maxConvWidth;
  private final int maxConvNumChannels;
  private final int maxConvNumFilters;
  private final int maxConvKernelSize;
  private final int maxFCHeight;
  private final int maxFCWidth;

  protected LMemInterface iface;

  public MaxDeepManager(MaxDeepEngineParameters params) {
    super(params);

    N                  = params.getNumPipes();
    C                  = params.getMultiPumpingFactor();
    freq               = params.getFreq();
    maxConvHeight      = params.getMaxConvHeight();
    maxConvWidth       = params.getMaxConvWidth();
    maxConvNumChannels = params.getMaxConvNumChannels();
    maxConvNumFilters  = params.getMaxConvNumFilters();
    maxConvKernelSize  = params.getMaxConvKernelSize();
    maxFCHeight        = params.getMaxFCHeight();
    maxFCWidth         = params.getMaxFCWidth();

    addMaxFileConstant("numPipes",           N);
    addMaxFileConstant("freq",               freq);
    addMaxFileConstant("multiPumpingFactor", C);
    addMaxFileConstant("maxConvHeight",      maxConvHeight);
    addMaxFileConstant("maxConvWidth",       maxConvWidth);
    addMaxFileConstant("maxConvNumChannels", maxConvNumChannels);
    addMaxFileConstant("maxConvNumFilters",  maxConvNumFilters);
    addMaxFileConstant("maxConvKernelSize",  maxConvKernelSize);
    addMaxFileConstant("maxFCHeight",        maxFCHeight);
    addMaxFileConstant("maxFCWidth",         maxFCWidth);

    // ManagerUtils.setDRAMMaxDeviceFrequency(this, params);
    // NOTE: This option will help timing when using multiple kernels
    // (2017-03-03)
    KernelConfiguration kernelConfiguration = this.getCurrentKernelConfig();
    kernelConfiguration.optimization.setUseGlobalClockBuffer(true);

    KernelBlock mpc = addKernel(
      new MultiPumpedConvolveKernel(
        makeKernelParameters(MULTI_PUMPED_CONVOLVE_KERNEL_NAME),
        1, maxConvKernelSize, 1, params.getDbg()));
    KernelBlock mpdp = addKernel(
      new MultiPumpedDotProductKernel(
        makeKernelParameters(MULTI_PUMPED_DOT_PRODUCT_KERNEL_NAME),
        1, 1, params.getDbg()));
    KernelBlock cache = addKernel(
      new ConvolutionLayerCacheKernel(
        makeKernelParameters(CONV_CACHE_KERNEL_NAME),
        maxConvHeight,
        maxConvWidth,
        maxConvNumChannels,
        maxConvNumFilters,
        maxConvKernelSize,
        params.getDbg()));
    KernelBlock post = addKernel(
      new ConvolutionLayerPostProcessKernel(
        makeKernelParameters(CONV_POST_PROCESS_KERNEL_NAME),
        maxConvHeight,
        maxConvWidth,
        maxConvNumChannels,
        maxConvNumFilters,
        maxConvKernelSize,
        params.getDbg()));
    KernelBlock fcCache = addKernel(
      new FullyConnectedLayerCacheKernel(
        makeKernelParameters(FC_CACHE_KERNEL_NAME),
        maxFCHeight,
        maxFCWidth));
    KernelBlock fcPost = addKernel(
      new FullyConnectedLayerPostProcessKernel(
        makeKernelParameters(FC_POST_PROCESS_KERNEL_NAME),
        maxFCHeight,
        maxFCWidth));
    KernelBlock paddingKernel = addKernel(
      new PaddingKernel(
        makeKernelParameters(PADDING_KERNEL_NAME)));
    KernelBlock paddingKernelFC = addKernel(
      new PaddingKernel(
        makeKernelParameters(PADDING_KERNEL_FC_NAME)));

    iface = addLMemInterface();

    ManagerUtils.addLinearStreamFromLMemToKernel(iface, cache, ConvolutionLayerCacheKernel.INP_NAME);
    ManagerUtils.addLinearStreamFromLMemToKernel(iface, cache, ConvolutionLayerCacheKernel.WGT_NAME);
    ManagerUtils.addLinearStreamFromLMemToKernel(iface, fcCache, FullyConnectedLayerCacheKernel.INP_NAME);
    ManagerUtils.addLinearStreamFromLMemToKernel(iface, fcCache, FullyConnectedLayerCacheKernel.WGT_NAME);
    ManagerUtils.addLinearStreamFromKernelToLMem(iface, paddingKernel, PaddingKernel.OUT_NAME, PaddingKernel.OUT_NAME + "_CONV");
    ManagerUtils.addLinearStreamFromKernelToLMem(iface, paddingKernelFC, PaddingKernel.OUT_NAME, PaddingKernel.OUT_NAME + "_FC");

    mpc.getInput(MultiPumpedConvolveKernel.INP_NAME)
      <== cache.getOutput(ConvolutionLayerCacheKernel.OUT_INP_NAME);
    mpc.getInput(MultiPumpedConvolveKernel.WGT_NAME)
      <== cache.getOutput(ConvolutionLayerCacheKernel.OUT_WGT_NAME);
    mpdp.getInput(MultiPumpedDotProductKernel.INP_NAME)
      <== fcCache.getOutput(FullyConnectedLayerCacheKernel.OUT_INP_NAME);
    mpdp.getInput(MultiPumpedDotProductKernel.WGT_NAME)
      <== fcCache.getOutput(FullyConnectedLayerCacheKernel.OUT_WGT_NAME);
    post.getInput(ConvolutionLayerPostProcessKernel.INP_NAME)
      <== mpc.getOutput(MultiPumpedConvolveKernel.OUT_NAME);
    fcPost.getInput(FullyConnectedLayerPostProcessKernel.INP_NAME)
      <== mpdp.getOutput(MultiPumpedDotProductKernel.OUT_NAME);
    paddingKernel.getInput(PaddingKernel.INP_NAME)
      <== post.getOutput(ConvolutionLayerPostProcessKernel.OUT_NAME);
    paddingKernelFC.getInput(PaddingKernel.INP_NAME)
      <== fcPost.getOutput(FullyConnectedLayerPostProcessKernel.OUT_NAME);

    config.setDefaultStreamClockFrequency(freq);
    ManagerClock clk
      = generateStreamClock(DEFAULT_KERNEL_CLK, freq);
    ManagerClock clockForMPC
      = generateStreamClock(MULTI_PUMPED_KERNEL_CLK, freq * C);

    cache.setClock(clk);
    post.setClock(clk);
    paddingKernel.setClock(clk);
    mpdp.setClock(clk);
    fcCache.setClock(clk);
    fcPost.setClock(clk);

    mpc.setClock(clockForMPC);
  }

  private EngineInterface interfaceDefault() {
    EngineInterface ei = new EngineInterface();

    InterfaceParam zero
      = ei.addConstant(0);
    InterfaceParam kernelSize
      = ei.addParam(
          "conv_kernel_size",
          CPUTypes.UINT32,
          "The kernel size of the current convolution layer computation"
        );
    InterfaceParam height 
      = ei.addParam(
          "conv_height",
          CPUTypes.UINT32,
          "The height of the current convolution layer computation"
        );
    InterfaceParam width 
      = ei.addParam(
          "conv_width",
          CPUTypes.UINT32,
          "The width of the current convolution layer computation"
        );
    InterfaceParam numChannels 
      = ei.addParam(
          "conv_num_channels",
          CPUTypes.UINT32,
          "The num of channels of the current convolution layer computation"
        );
    InterfaceParam numFilters 
      = ei.addParam(
          "conv_num_filters",
          CPUTypes.UINT32,
          "The number of filters of the current convolution layer computation"
        );
    InterfaceParam numOutput
      = ((height - kernelSize + 1) *
         (width - kernelSize + 1) *
         numFilters
        );
    InterfaceParam fcHeight 
      = ei.addParam(
          "fc_height",
          CPUTypes.UINT32,
          "The height of the current fully-connected layer computation"
        );
    InterfaceParam fcWidth 
      = ei.addParam(
          "fc_width",
          CPUTypes.UINT32,
          "The width of the current fully-connected layer computation"
        );

    ei.setTicks(CONV_CACHE_KERNEL_NAME,
        height * width * numChannels * numFilters);
    ei.setTicks(MULTI_PUMPED_CONVOLVE_KERNEL_NAME,
        numOutput * numChannels);
    ei.setTicks(CONV_POST_PROCESS_KERNEL_NAME,
        numOutput * numChannels);
    ei.setTicks(FC_CACHE_KERNEL_NAME,
        fcHeight * fcWidth);
    ei.setTicks(MULTI_PUMPED_DOT_PRODUCT_KERNEL_NAME,
        fcHeight * fcWidth);
    ei.setTicks(FC_POST_PROCESS_KERNEL_NAME,
        fcHeight * fcWidth);

    ei.setScalar(
      CONV_CACHE_KERNEL_NAME,
      ConvolutionLayerCacheKernel.SCALAR_HEIGHT_INP_NAME,
      height);
    ei.setScalar(
      CONV_CACHE_KERNEL_NAME,
      ConvolutionLayerCacheKernel.SCALAR_WIDTH_INP_NAME,
      width);
    ei.setScalar(
      CONV_CACHE_KERNEL_NAME,
      ConvolutionLayerCacheKernel.SCALAR_NUM_CHANNELS_INP_NAME,
      numChannels);
    ei.setScalar(
      CONV_CACHE_KERNEL_NAME,
      ConvolutionLayerCacheKernel.SCALAR_NUM_FILTERS_INP_NAME,
      numFilters);
    ei.setScalar(
      CONV_CACHE_KERNEL_NAME,
      ConvolutionLayerCacheKernel.SCALAR_KERNEL_SIZE_INP_NAME,
      kernelSize);

    ei.setScalar(
      CONV_POST_PROCESS_KERNEL_NAME,
      ConvolutionLayerPostProcessKernel.SCALAR_HEIGHT_INP_NAME,
      height);
    ei.setScalar(
      CONV_POST_PROCESS_KERNEL_NAME,
      ConvolutionLayerPostProcessKernel.SCALAR_WIDTH_INP_NAME,
      width);
    ei.setScalar(
      CONV_POST_PROCESS_KERNEL_NAME,
      ConvolutionLayerPostProcessKernel.SCALAR_NUM_CHANNELS_INP_NAME,
      numChannels);
    ei.setScalar(
      CONV_POST_PROCESS_KERNEL_NAME,
      ConvolutionLayerPostProcessKernel.SCALAR_NUM_FILTERS_INP_NAME,
      numFilters);
    ei.setScalar(
      CONV_POST_PROCESS_KERNEL_NAME,
      ConvolutionLayerPostProcessKernel.SCALAR_KERNEL_SIZE_INP_NAME,
      kernelSize);
    
    ei.setScalar(
      MULTI_PUMPED_CONVOLVE_KERNEL_NAME,
      MultiPumpedConvolveKernel.SCALAR_KERNEL_SIZE_NAME,
      kernelSize);

    ei.setScalar(
      FC_CACHE_KERNEL_NAME,
      FullyConnectedLayerCacheKernel.SCALAR_HEIGHT_NAME,
      fcHeight);
    ei.setScalar(
      FC_CACHE_KERNEL_NAME,
      FullyConnectedLayerCacheKernel.SCALAR_WIDTH_NAME,
      fcWidth);

    ei.setScalar(
      FC_POST_PROCESS_KERNEL_NAME,
      FullyConnectedLayerPostProcessKernel.SCALAR_HEIGHT_NAME,
      fcHeight);
    ei.setScalar(
      FC_POST_PROCESS_KERNEL_NAME,
      FullyConnectedLayerPostProcessKernel.SCALAR_WIDTH_NAME,
      fcWidth);

    InterfaceParam burstSize = ei.addConstant(384);
    InterfaceParam inpSize
      = height * width * numChannels;
    InterfaceParam wgtSize
      = kernelSize * kernelSize * numChannels * numFilters;
    InterfaceParam outSize
      = numOutput;

    InterfaceParam burstAlignedInpSize
      = burstAlignedSize(inpSize, CPUTypes.UINT32.sizeInBytes(), burstSize)
        * CPUTypes.UINT32.sizeInBytes();
    InterfaceParam burstAlignedWgtSize
      = burstAlignedSize(wgtSize, CPUTypes.UINT32.sizeInBytes(), burstSize)
        * CPUTypes.UINT32.sizeInBytes();
    InterfaceParam burstAlignedOutSize
      = burstAlignedSize(outSize, CPUTypes.UINT32.sizeInBytes(), burstSize)
        * CPUTypes.UINT32.sizeInBytes();

    ei.setTicks(PADDING_KERNEL_NAME,
      burstAlignedSize(outSize, CPUTypes.UINT32.sizeInBytes(), burstSize));
    ei.setScalar(
      PADDING_KERNEL_NAME,
      PaddingKernel.SCALAR_NUM_INP,
      outSize);
    ei.setScalar(
      PADDING_KERNEL_NAME,
      PaddingKernel.SCALAR_TOTAL_CYCLES,
      burstAlignedSize(outSize, CPUTypes.UINT32.sizeInBytes(), burstSize));

    InterfaceParam fcInpSize
      = fcWidth;
    InterfaceParam fcWgtSize
      = fcHeight * fcWidth;
    InterfaceParam fcOutSize
      = fcHeight;

    InterfaceParam burstAlignedFCInpSize
      = burstAlignedSize(fcInpSize, CPUTypes.UINT32.sizeInBytes(), burstSize)
        * CPUTypes.UINT32.sizeInBytes();
    InterfaceParam burstAlignedFCWgtSize
      = burstAlignedSize(fcWgtSize, CPUTypes.UINT32.sizeInBytes(), burstSize)
        * CPUTypes.UINT32.sizeInBytes();
    InterfaceParam burstAlignedFCOutSize
      = burstAlignedSize(fcOutSize, CPUTypes.UINT32.sizeInBytes(), burstSize)
        * CPUTypes.UINT32.sizeInBytes();

    ei.setTicks(PADDING_KERNEL_FC_NAME,
      burstAlignedSize(fcOutSize, CPUTypes.UINT32.sizeInBytes(), burstSize));
    ei.setScalar(
      PADDING_KERNEL_FC_NAME,
      PaddingKernel.SCALAR_NUM_INP,
      fcOutSize);
    ei.setScalar(
      PADDING_KERNEL_FC_NAME,
      PaddingKernel.SCALAR_TOTAL_CYCLES,
      burstAlignedFCOutSize);

    InterfaceParam baseAddr = zero;

    ei.setLMemLinear(
      ConvolutionLayerCacheKernel.INP_NAME,
      baseAddr,
      burstAlignedInpSize);
    baseAddr += burstAlignedInpSize;

    ei.setLMemLinear(ConvolutionLayerCacheKernel.WGT_NAME,
      baseAddr,
      burstAlignedWgtSize);
    baseAddr += burstAlignedWgtSize;

    ei.setLMemLinear(PaddingKernel.OUT_NAME + "_CONV",
      baseAddr,
      burstAlignedOutSize);
    baseAddr += burstAlignedOutSize;

    ei.setLMemLinear(
      FullyConnectedLayerCacheKernel.INP_NAME,
      baseAddr,
      burstAlignedFCInpSize);
    baseAddr += burstAlignedFCInpSize;

    ei.setLMemLinear(FullyConnectedLayerCacheKernel.WGT_NAME,
      baseAddr,
      burstAlignedFCWgtSize);
    baseAddr += burstAlignedFCWgtSize;

    ei.setLMemLinear(PaddingKernel.OUT_NAME + "_FC",
      baseAddr,
      burstAlignedOutSize);
    baseAddr += burstAlignedFCOutSize;

    ManagerUtils.ignoreLMemStreams(ei);
    return ei;
  }

  private InterfaceParam burstAlignedSize(
    InterfaceParam num,
    int size,
    InterfaceParam burstSize
  ) {
    InterfaceParam length = num * size;
    InterfaceParam burstAlignedLength
      = InterfaceMath.ceil(length.cast(CPUTypes.FLOAT) / burstSize.cast(CPUTypes.FLOAT));
    return burstAlignedLength.cast(CPUTypes.UINT32) * burstSize / size;
  }

  public static void main(String [] args) {
    MaxDeepEngineParameters params = new MaxDeepEngineParameters(args);
    MaxDeepManager manager = new MaxDeepManager(params);

    manager.createSLiCinterface(ManagerUtils.dramWrite(manager, manager.iface));
    manager.createSLiCinterface(ManagerUtils.dramRead(manager, manager.iface));
    manager.createSLiCinterface(manager.interfaceDefault());
    // ManagerUtils.setDRAMMaxDeviceFrequency(manager, params);
    ManagerUtils.setFullBuild(manager, BuildConfig.Effort.HIGH, 4, 4);

    manager.build();
  }
}
