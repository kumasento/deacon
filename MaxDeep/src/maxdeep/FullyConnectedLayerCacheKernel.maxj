package maxdeep;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
// import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

public class FullyConnectedLayerCacheKernel extends Kernel {

  public static final String INP_NAME           = "FC_CACHE_INP";
  public static final String WGT_NAME           = "FC_CACHE_WGT";
  public static final String OUT_INP_NAME       = "FC_CACHE_OUT_INP";
  public static final String OUT_WGT_NAME       = "FC_CACHE_OUT_WGT";
  public static final String SCALAR_HEIGHT_NAME = "FC_CACHE_SCALAR_HEIGHT";
  public static final String SCALAR_WIDTH_NAME  = "FC_CACHE_SCALAR_WIDTH";

  /**
   * This is the kernel for storing the input vector of the FC layer.
   * Also it helps organise the output to the MPDP.
   *
   * @author Ruizhe Zhao
   * @since 2017-03-08
   * @param params The kernel parameters
   * @param maxHeight The maximum height that this cache can support
   * @param maxWidth The maximum width that this cache kernel can support
   */
  public FullyConnectedLayerCacheKernel(
    KernelParameters params,
    int maxHeight,
    int maxWidth
  ) {
    super(params);

    DFEType type = dfeUInt(32);

    /**
     * Scalar inputs:
     * - height: height of the current FC layer
     * - width: width of the current FC layer
     */
    DFEVar height = io.scalarInput(SCALAR_HEIGHT_NAME, dfeUInt(32));
    DFEVar width  = io.scalarInput(SCALAR_WIDTH_NAME, dfeUInt(32));

    /**
     * Counters
     */
    DFEVar idx = control.count.simpleCounter(32, height * width);
    DFEVar h = KernelMath.divMod(idx, width).getQuotient().cast(dfeUInt(32));
    DFEVar w = KernelMath.divMod(idx, width).getRemainder().cast(dfeUInt(32));

    /**
     * Input
     */
    DFEVar inpEnable = dfeBool().newInstance(this);
    inpEnable <== h === 0;
    DFEVar inp = io.input(INP_NAME, type, inpEnable);
    
    /**
     * Cache:
     * Only write to the cache when we are working on the first row.
     */
    int cacheSize = maxWidth;
    int cacheAddrBits = MathUtils.bitsToAddress(cacheSize);
    DFEType cacheAddrType = dfeUInt(cacheAddrBits);
    Memory<DFEVar> cache = mem.alloc(type, cacheSize);
    DFEVar cacheWriteEnable = inpEnable;
    DFEVar cacheWriteValue = inp;
    DFEVar cacheWriteAddr = w.cast(cacheAddrType);
    DFEVar out = cache.port(
      cacheWriteAddr,
      cacheWriteValue,
      cacheWriteEnable,
      Mem.RamWriteMode.WRITE_FIRST);

    /**
     * Weight
     */
    DFEVar wgt = io.input(WGT_NAME, type);

    /**
     * Output
     */
    io.output(OUT_INP_NAME, out, type);
    io.output(OUT_WGT_NAME, wgt, type);
  }
}
