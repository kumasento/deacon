package maxdeep;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;

import com.custom_computing_ic.dfe_snippets.utils.Reductions;

public class MultiPumpedDotProductKernel extends Kernel {

  public static final String INP_NAME = "MPDP_INP";
  public static final String WGT_NAME = "MPDP_WGT";
  public static final String OUT_NAME = "MPDP_OUT";

  public static final String SCALAR_LENGTH_INP_NAME = "MPDP_LENGTH_INP";
  
  /**
   * This is the kernel to perform multi-pumped dot-product within the 
   * fully connected layer.
   *
   * @author Ruizhe Zhao
   * @since 2017-03-06
   *
   * @param params The kernel parameters
   * @param numRowPipes The number of pipes in row (parallel)
   * @param numColPipes The number of pipes in column (parallel)
   * @param dbg The debug signal
   */
  public MultiPumpedDotProductKernel(
    KernelParameters params,
    int numRowPipes,
    int numColPipes,
    boolean dbg
  ) {
    super(params);

    DFEType type = dfeUInt(32);

    int inpVecSize = numColPipes;
    DFEVectorType<DFEVar> inpVecType
      = new DFEVectorType<DFEVar>(type, inpVecSize);
    DFEVector<DFEVar> inpVec = io.input(INP_NAME, inpVecType);

    int wgtVecSize = numRowPipes * numColPipes;
    DFEVectorType<DFEVar> wgtVecType
      = new DFEVectorType<DFEVar>(type, wgtVecSize);
    DFEVector<DFEVar> wgtVec = io.input(WGT_NAME, wgtVecType);

    int outVecSize = numRowPipes;
    DFEVectorType<DFEVar> outVecType
      = new DFEVectorType<DFEVar>(type, outVecSize);
    DFEVector<DFEVar> outVec = outVecType.newInstance(this);

    for (int i = 0; i < numRowPipes; i ++) {
      DFEVector<DFEVar> tmpVec = inpVecType.newInstance(this); 

      for (int j = 0; j < numColPipes; j ++) {
        DFEVar inp = inpVec[j];
        DFEVar wgt = wgtVec[i * numColPipes + j];
        tmpVec[j] <== inp * wgt;
      }

      outVec[i] <== Reductions.reduce(tmpVec);
    }

    io.output(OUT_NAME, outVec, outVecType);
  }
}
